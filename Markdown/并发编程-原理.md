# 并发编程-原理

## Volatile原理

### 内存屏障指令

为了实现 volatile 内存语义（即内存可见性），JMM 会限制特定类型的编译器和处理器重排序。为此，JMM 针对编译器制定了 volatile 重排序规则表，如下所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/ab7f14de806c48ffb73dcacbe62c3683.png)

使用 volatile 修饰变量时，根据 volatile 重排序规则表，Java 编译器在生成字节码时，会在指令序列中插入内存屏障指令来禁止特定类型的处理器重排序。

**内存屏障是一组处理器指令，它的作用是禁止指令重排序和解决内存可见性的问题。**

JMM 把内存屏障指令分为下列四类：

![在这里插入图片描述](https://img-blog.csdnimg.cn/5001ab2425d448a8b83e532e40868a51.png)

StoreLoad 屏障是一个全能型的屏障，它同时具有其他三个屏障的效果。所以执行该屏障开销会很大，因为它使处理器要把缓存中的数据全部刷新到内存中。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8dbeef0aef90405b953d426e98f2dcfd.png)

从上图，我们可以知道 volatile 读 / 写插入内存屏障规则：

在每个 volatile 读操作的后面插入 LoadLoad 屏障和 LoadStore 屏障。
在每个 volatile 写操作的前后分别插入一个 StoreStore 屏障和一个 StoreLoad 屏障。
也就是说，编译器不会对 volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与volatile 写前面的任意内存操作重排序。

### happens-before 概述

上面我们讲述了重排序原则，为了提高处理速度， JVM 会对代码进行编译优化，也就是指令重排序优化，但是并发编程下指令重排序也会带来一些安全隐患：如指令重排序导致的多个线程操作之间的不可见性。为了理解 JMM 提供的内存可见性保证，让程序员再去学习复杂的重排序规则以及这些规则的具体实现，那么程序员的负担就太重了，严重影响了并发编程的效率。

所以从 JDK5 开始，提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。

happens-before 规则如下：

程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。
监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。
volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。
传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。
start() 规则：Thread.start() 的调用会 happens-before 于启动线程里面的动作。
join() 规则：Thread 中的所有动作都 happens-before 于其他线程从 Thread.join() 中成功返回。
这里特别说明一下，happens-before 规则不是描述实际操作的先后顺序，它是用来描述可见性的一种规则。

原文链接：https://blog.csdn.net/weixin_45476233/article/details/121558113



### double-checked lock问题

```java
package juc.jmm.pattern;

import lombok.extern.slf4j.Slf4j;

@Slf4j(topic = "singleton")
public class SingletonTest {
    private static SingletonTest INSTANTCE;

    /**
     * 尽可能缩小同步代码块范围
     */
    public static synchronized SingletonTest getSingleton() {
        if (INSTANTCE == null) {
            INSTANTCE = new SingletonTest();
        }
        return INSTANTCE;
    }

    /**
     * 相对上面的方法缩小了同步代码块，但是每次获取实例都需要加锁解锁
     */
    public static SingletonTest getSingleton2() {
        synchronized (SingletonTest.class) {
            if (INSTANTCE == null) {
                INSTANTCE = new SingletonTest();
            }
        }
        return INSTANTCE;
    }

    /**
     * 只有首次调用需要加锁，但因为第一个if判断在同步代码块外导致了一个非常隐蔽的问题，
     * 由于new SingletonTest()不是原子操作，执行时可能出现指令重排序的情况
     * 正常过程如下：
     * <p>
     * 1. 分配内存空间
     * 2. 初始化Singleton实例
     * 3. 赋值 instance 实例引用
     * <p>
     * 重排序以后可能会出现：
     * <p>
     * 1. 分配内存空间
     * 2. 赋值 instance 实例引用
     * 3. 初始化Singleton实例
     * 这样重排序并不影响单线程的执行结果，JVM是允许的。但是在多线程中就会出问题。
     * <p>
     * 当重排序以后，线程B 拿到了不为null 的instance实例引用，但是并没有被初始化，然后线程B使用了一个没有被初始化的对象引用，就出问题了。
     */
    public static SingletonTest getSingleton3() {
        if (INSTANTCE == null) {
            //synchronized不能防止指令重排序，重排序遵循"as-if-serial"原则
            //
            synchronized (SingletonTest.class) {
                if (INSTANTCE == null) {
                    INSTANTCE = new SingletonTest();
                }
            }
        }
        return INSTANTCE;
    }

    /**
     * 双重检测问题解决
     * 方案一
     * 内部类是懒加载，只有在第一次使用时才会初始化
     * 方案二
     * 添加volatile关键字
     */
    public static class InnerClass {
        public static final SingletonTest INSTANCE = new SingletonTest();
    }

    private SingletonTest() {

    }

}

```



假设有两个线程A、B，当线程A 执行到 instance = new Singleton(); 时，线程B执行到 if (instance == null)。这里如果正常，那就是 Singleton被新建，并赋值给 instance ，线程B 拿到instance时不为null，同时开始使用 instance。

由于 instance = new Singleton();的执行过程可能被重排序。

正常过程如下：

1. 分配内存空间
2. 初始化Singleton实例
3. 赋值 instance 实例引用

重排序以后可能会出现：

1. 分配内存空间
2. 赋值 instance 实例引用
3. 初始化Singleton实例

这样重排序并不影响单线程的执行结果，JVM是允许的。但是在多线程中就会出问题。

当重排序以后，线程B 拿到了不为null 的instance实例引用，但是并没有被初始化，然后线程B使用了一个没有被初始化的对象引用，就出问题了。

原文链接：https://blog.csdn.net/u013490280/article/details/108722926



## LongAdder原理

### 关键字段

```java
    /**
     * Table of cells. When non-null, size is a power of 2.
     */
    transient volatile Cell[] cells;

    /**
     * Base value, used mainly when there is no contention, but also as
     * a fallback during table initialization races. Updated via CAS.
     */
    transient volatile long base;

    /**
     * Spinlock (locked via CAS) used when resizing and/or creating Cells.
     * 1 表示加锁
     */
    transient volatile int cellsBusy;
```

cas锁

```java
@Slf4j(topic = "lockCas")
public class LockCas {

    /**
     * 0 表示无锁
     * 1 表示有锁
     */
    public final AtomicInteger lock = new AtomicInteger(0);

    public void lock() {
        do {
        } while (!lock.compareAndSet(0, 1));
    }

    public void unlock() {
        lock.set(0);
        log.debug("unlock...");
    }

    public static void main(String[] args) {
        LockCas lock = new LockCas();
        new Thread(() -> {
            log.debug("start...");
            lock.lock();

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }).start();

        new Thread(() -> {
            log.debug("start...");
            lock.lock();

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }).start();

    }
}
```



### 原理之伪共享

Cell为累加单元

```java
    // @sun.misc.Contended  防止缓存行伪共享
    @sun.misc.Contended 
    static final class Cell {
        volatile long value;
        Cell(long x) { value = x; }
        //最重要的方法，用cas方式进行累加
        final boolean cas(long cmp, long val) {
            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
        }
        //省略不重要代码
    }
```

因为CPU与内存的速度差异很大，需要预读取数据到缓存来提升效率

而缓存已缓存行为单位，每个缓存行对应着一块内存，一般是64bit，8个long

缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存中

CPU要保证数据的一致性，如果某个CPU核心更改了数据，其他CPU核心对应的整个缓存行必须失效。

![](\picture\longAdder原理.jpg)

![](\picture\longAdder原理2.jpg)

## Unsafe原理

```java
@Slf4j(topic = "unsafe")
public class UnsafeTest {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
        //Class com.hyh.cas.UnsafeTest can not access a member of class sun.misc.Unsafe with modifiers "private static final"
        theUnsafe.setAccessible(true);

        Unsafe unsafe = (Unsafe) theUnsafe.get(null);

        log.debug("unsafe={}", unsafe);

        //1. 获取域的偏移地址
        long idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField("id"));
        long nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField("name"));

        Teacher teacher = new Teacher();
        //2. 执行CAS操作
        log.debug("id cas = {}", unsafe.compareAndSwapInt(teacher, idOffset, 0, 1));
        log.debug("name cas = {}", unsafe.compareAndSwapObject(teacher, nameOffset, null, "hyh"));


    }
}

@Data
class Teacher {
    volatile String name;

    volatile int id;
}
```

## final原理

`final`原理对比`volatile`关键字就会非常好理解，

final变量写入操作后有一个写屏障（同步到主存），保证线程的可见性。

读取final变量时候，如果加了final则读取数值是在常量池中取数据，提高了效率



## AQS原理

全称是`AbstractQueuedSynchronizer`，是阻塞式锁和相关同步器工具的框架



特点：

- 用state属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取和释放锁
  - `getState`获取`state`
  - `setState`设置`state`
  - compareAndSetState乐观锁机制设置state
  - 独占模式是一个线程能够访问资源，共享模式可以允许多个线程访问资源

- 提供了`FIFO`的等待队列，类似于`Monitor`的`EntryList`
- 条件变量实现等待、唤醒机制，支持多个条件变量，类似`Monitor`的`WaitSet`



子类主要实现这样一些方法，默认抛出`UnsupportedOperationException`

- tryAcquire
- tryRelease
- tryAcquireShared
- tryReleaseShared
- isHeldExclusively

```java
package com.hyh.jucutil.threadpool.aqs;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

@Slf4j(topic = "aqsTest")
public class AQSTest {
    public static void main(String[] args) {
//        ReentrantLock reentrantLock = new ReentrantLock();
//        reentrantLock.lock();
        MyLock lock = new MyLock();
        new Thread(() -> {
            lock.lock();
            log.debug("locked...");
            //不可重入，会阻塞住
            //重复加锁会阻塞
//            lock.lock();
//            log.debug("locked...");
            try {
                log.debug("running...");
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                log.debug("unlocking...");
                lock.unlock();
            }
        }, "t1").start();

        new Thread(() -> {
            lock.lock();
            try {
                log.debug("running...");
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                log.debug("unlocking...");
                lock.unlock();
            }
        }, "t2").start();

    }
}

/**
 * 自定义锁，不可重入 独占式
 */
class MyLock implements Lock {

    public MySync sync;

    public MyLock() {
        sync = new MySync();
    }

    /**
     * 加锁
     */
    @Override
    public void lock() {
        sync.acquire(1);
    }

    /**
     * 可打断地加锁
     */
    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    /**
     * 尝试加锁
     */
    @Override
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    /**
     * 有超时时间的尝试加锁
     */
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(time));
    }

    /**
     * 解锁
     */
    @Override
    public void unlock() {
        sync.release(1);
    }

    /**
     * 新的条件变量
     */
    @Override
    public Condition newCondition() {
        return sync.newCondition();
    }

    static class MySync extends AbstractQueuedSynchronizer {

        @Override
        protected boolean tryAcquire(int arg) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            setExclusiveOwnerThread(null);
            //state 是volatile变量，写操作后会将前面涉及写操作的变量同步到主存
            setState(0);
            return true;
        }

        /**
         * 共享模式需要实现次方法
         */
        @Override
        protected int tryAcquireShared(int arg) {
            return super.tryAcquireShared(arg);
        }

        /**
         * 共享模式需要实现次方法
         */
        @Override
        protected boolean tryReleaseShared(int arg) {
            return super.tryReleaseShared(arg);
        }

        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        public Condition newCondition() {
            return new ConditionObject();
        }
    }
}

```



## ReentrantLock原理

### ![image-20220418232028225](\picture\image-20220418232028225.png)1. 非公平锁实现原理

#### 加锁解锁流程

ReentrantLock默认使用非公平锁

```java
    /**
     * Creates an instance of {@code ReentrantLock}.
     * This is equivalent to using {@code ReentrantLock(false)}.
     */
    public ReentrantLock() {
        sync = new NonfairSync();
    }
```

NonfairSync继承自AQS

没有竞争时

![image-20220419215752575](\picture\image-20220419215752575.png)

第一个竞争出现时

![image-20220419215810072](\picture\image-20220419215810072.png)

1. `Thread-1`做`CAS`，尝试将`state`由`0`改为`1`，结果失败了

2. 进入`tryAcquire`，这时`state`已经是`1`，结果仍然是失败

3. 接着进入`addWaiter`逻辑，构造`Node`队列，

   - 下图中黄色三角表示`Node`的`waitStatus`状态，其中`0`为默认正常状态
   - `Node`的创建是懒惰的
   - 其中的第一个`Node`称为哨兵或哑元（Dummy）即head，用来占位，并不关联线程

   ![image-20220419220633601](\picture\image-20220419220633601.png)

4. 接着进入`acquireQueued`

   - 死循环中不断尝试获得锁，失败后进入`park`阻塞

   - 如果自己排在`head`的后面（排第二），那么再次`tryAcquire`尝试获取锁

     - 加锁失败时，进入`shouldParkAfterFailedAcquire`，将前驱`node`（此时前驱为`head`）的`waitStatus`改为`-1`，这次返回`false`

       ![image-20220419222818933](\picture\image-20220419222818933.png)

     - 返回`acquireQueued`，重复上述逻辑，这时因为前驱`node`的`waitStatus`已经是`-1`，这次返回`true`
     - 进入`parkAndCheckInterrupt`，`Thread-1`进入`park`状态（灰色表示）

     ![image-20220419223401098](\picture\image-20220419223401098.png)

5. 若`Thread-0`不释放锁，此时有多个线程竞争，变成以下状态

![image-20220419223714502](\picture\image-20220419223714502.png)

6. `Thread-0`释放锁，进入`tryRelease`流程，如果成功

- 设置`exclusiveOwnerThread`为`null`
- 设置`state`状态为`0`

![image-20220419224808668](\picture\image-20220419224808668.png)

7. 当`head`不为`null`，并且`head`的`waitStatus=-1`，进入`unparkSuccessor`

8. 先找`head`的下一个`node`，若此`node`的`waitStauts`为`0`则`unparknode`持有的线程（本例中即为`Thread-1`）

9. `Thread-1`恢复，继续执行`acquireQueued`，通过`tryAcquire`尝试获取锁，

   - 若被其他线程先成功获取锁，假设新来了一个线程`Thread-4`（非公平的体现）
     - `Thread-4`被设置为`exclusiveOwnerThread`，state`设置`为`1`
     - `Thread-1`再次进入`acquireQueued`，获取锁失败，重新进入`park`阻塞

   - 若此时没有竞争成功获得锁则修改`head`为成功获得锁的`node`，见下述代码，原来的`head`从链表中断开（可被GC）

```java
    private void setHead(Node node) {
        head = node;
        node.thread = null;
        node.prev = null;
    }
```

### 2. 可重入原理

```java
        /**
         * lock.lock()->sync.lock()->sync.acquire(1)->sync.tryAcquire(1)->sync.nonfairTryAcquire(1)
         * tryAcquire会调用此方法尝试获取锁
         * Performs non-fair tryLock.  tryAcquire is implemented in
         * subclasses, but both need nonfair try for trylock method.
         */
        final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                //使用CAS尝试获取锁，这里体现了非公平性，不去检查AQS队列
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            //如果已经获得锁则current == getExclusiveOwnerThread()为true，表明发生了锁重入
            else if (current == getExclusiveOwnerThread()) {
                //state++并校验获取锁的次数是否溢出
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
       
        /*
        * lock.unlock()->sync.release(1)->tryRelease(1)
        * 
        */
        protected final boolean tryRelease(int releases) {
            //state--
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            //只有state==0表明所有重入锁都已释放，
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
```



### 3. 可打断原理

#### 不可打断模式

此模式下，即使被打断，仍会驻留在AQS队列中，等获得锁后方能继续运行（继续运行，打断标记设为true）

```java
    /**
     * Acquires in exclusive uninterruptible mode for thread already in
     * queue. Used by condition wait methods as well as acquire.
     *
     * @param node the node
     * @param arg the acquire argument
     * @return {@code true} if interrupted while waiting
     */
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    //获得锁返回打断标记
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    /**
     * Convenience method to park and then check if interrupted
     *
     * @return {@code true} if interrupted
     */
    private final boolean parkAndCheckInterrupt() {
        //打断标记为true时或park后其它线程调用线程的interrupt()，park会失效
        LockSupport.park(this);
        //interrupted会清除打断标记
        return Thread.interrupted();
    }

    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            // acquireQueued返回的打断标记为true时进入selfInterrupt
            selfInterrupt();
    }

    /**
     * Convenience method to interrupt current thread.
     */
    static void selfInterrupt() {
        //自己打断自己
        Thread.currentThread().interrupt();
    }

```

#### 可打断模式



```java
    /**
     * Acquires in exclusive mode, aborting if interrupted.
     * Implemented by first checking interrupt status, then invoking
     * at least once {@link #tryAcquire}, returning on
     * success.  Otherwise the thread is queued, possibly repeatedly
     * blocking and unblocking, invoking {@link #tryAcquire}
     * until success or the thread is interrupted.  This method can be
     * used to implement method {@link Lock#lockInterruptibly}.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     * @throws InterruptedException if the current thread is interrupted
     */
    public final void acquireInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (!tryAcquire(arg))
            // 没有获得锁进入可打断流程
            doAcquireInterruptibly(arg);
    }

    /**
     * Acquires in exclusive interruptible mode.
     * @param arg the acquire argument
     */
    private void doAcquireInterruptibly(int arg)
        throws InterruptedException {
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    //被打断时直接抛出被打断异常
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```





### 2. 公平锁实现原理

与公平锁的主要区别在于`tryAcquire`,尝试获取锁之前会检查AQS

```java
    final void lock() {
        acquire(1);
    }

    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
        /**
         * Fair version of tryAcquire.  Don't grant access unless
         * recursive call or no waiters or is first.
         */
        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                //获取锁之前检查AQS队列
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
    }
    /**
     * Queries whether any threads have been waiting to acquire longer
     * than the current thread.
     *
     * <p>An invocation of this method is equivalent to (but may be
     * more efficient than):
     *  <pre> {@code
     * getFirstQueuedThread() != Thread.currentThread() &&
     * hasQueuedThreads()}</pre>
     *
     * <p>Note that because cancellations due to interrupts and
     * timeouts may occur at any time, a {@code true} return does not
     * guarantee that some other thread will acquire before the current
     * thread.  Likewise, it is possible for another thread to win a
     * race to enqueue after this method has returned {@code false},
     * due to the queue being empty.
     *
     * <p>This method is designed to be used by a fair synchronizer to
     * avoid <a href="AbstractQueuedSynchronizer#barging">barging</a>.
     * Such a synchronizer's {@link #tryAcquire} method should return
     * {@code false}, and its {@link #tryAcquireShared} method should
     * return a negative value, if this method returns {@code true}
     * (unless this is a reentrant acquire).  For example, the {@code
     * tryAcquire} method for a fair, reentrant, exclusive mode
     * synchronizer might look like this:
     *
     *  <pre> {@code
     * protected boolean tryAcquire(int arg) {
     *   if (isHeldExclusively()) {
     *     // A reentrant acquire; increment hold count
     *     return true;
     *   } else if (hasQueuedPredecessors()) {
     *     return false;
     *   } else {
     *     // try to acquire normally
     *   }
     * }}</pre>
     *
     * @return {@code true} if there is a queued thread preceding the
     *         current thread, and {@code false} if the current thread
     *         is at the head of the queue or the queue is empty
     * @since 1.7
     */
    public final boolean hasQueuedPredecessors() {
        // The correctness of this depends on head being initialized
        // before tail and on head.next being accurate if the current
        // thread is first in queue.
        Node t = tail; // Read fields in reverse initialization order
        Node h = head;
        Node s;
        //h != t 表示队列中没有node
        return h != t &&
            //(s = h.next) == null表示队列中没有等待获取锁的节点，只有哨兵
            //队列中有节点但当前线程不是队列中的第一个节点
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }

```



## 条件变量原理

每个条件变量其实就对应着一个等待队列，其实现类是`ConditionObject`

### await流程

开始`Thread-0`持有锁，调用`await`，进入`addConditionWaiter`，创建新的`Node`，`waitStauts`初始为为`-2`（Node.CONDITION）,关联`Thread-0`，加入等待队列尾部（FIFO单向链表）

![image-20220420224707423](\picture\image-20220420224707423.png)

接下来进入`AQS`的fullyRelease，首先会检查是否获得了锁，否则会抛出`IllegalMonitorStateException`（因可能发生了锁重入，要把所有的锁都释放掉），然后释放同步器上的锁

![image-20220420224949574](\picture\image-20220420224949574.png)

`upark` `AQS`队列中的下一个节点，竞争锁，假设没有竞争，那么`Thread-1`成功获得锁

![image-20220420230305080](\picture\image-20220420230305080.png)

`park`阻塞`Thread-0`

![image-20220420230342545](\picture\image-20220420230342545.png)



### signal流程

假设`Thread-1`要来唤醒`Thread-0`

![image-20220420230445470](\picture\image-20220420230445470.png)

进入`doSignal`，首先检查是否获得了锁，然后再`condition`的链表中找第一个`Node`即`firstWaiter`

![image-20220420230833664](\picture\image-20220420230833664.png)

执行`transferForSignal`，将该`Node`加入`AQS`队列尾部，将`Thread-0`的`waitStatus`改为`0`，`Thread-1`的`waitStatus`改为`-1`

![image-20220420232730372](\picture\image-20220420232730372.png)

`Thread-1`释放锁进入`unlock`。
