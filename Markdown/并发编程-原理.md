# 并发编程-原理

## Volatile原理

### 内存屏障指令

为了实现 volatile 内存语义（即内存可见性），JMM 会限制特定类型的编译器和处理器重排序。为此，JMM 针对编译器制定了 volatile 重排序规则表，如下所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/ab7f14de806c48ffb73dcacbe62c3683.png)

使用 volatile 修饰变量时，根据 volatile 重排序规则表，Java 编译器在生成字节码时，会在指令序列中插入内存屏障指令来禁止特定类型的处理器重排序。

**内存屏障是一组处理器指令，它的作用是禁止指令重排序和解决内存可见性的问题。**

JMM 把内存屏障指令分为下列四类：

![在这里插入图片描述](https://img-blog.csdnimg.cn/5001ab2425d448a8b83e532e40868a51.png)

StoreLoad 屏障是一个全能型的屏障，它同时具有其他三个屏障的效果。所以执行该屏障开销会很大，因为它使处理器要把缓存中的数据全部刷新到内存中。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8dbeef0aef90405b953d426e98f2dcfd.png)

从上图，我们可以知道 volatile 读 / 写插入内存屏障规则：

在每个 volatile 读操作的后面插入 LoadLoad 屏障和 LoadStore 屏障。
在每个 volatile 写操作的前后分别插入一个 StoreStore 屏障和一个 StoreLoad 屏障。
也就是说，编译器不会对 volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与volatile 写前面的任意内存操作重排序。

### happens-before 概述

上面我们讲述了重排序原则，为了提高处理速度， JVM 会对代码进行编译优化，也就是指令重排序优化，但是并发编程下指令重排序也会带来一些安全隐患：如指令重排序导致的多个线程操作之间的不可见性。为了理解 JMM 提供的内存可见性保证，让程序员再去学习复杂的重排序规则以及这些规则的具体实现，那么程序员的负担就太重了，严重影响了并发编程的效率。

所以从 JDK5 开始，提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。

happens-before 规则如下：

程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。
监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。
volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。
传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。
start() 规则：Thread.start() 的调用会 happens-before 于启动线程里面的动作。
join() 规则：Thread 中的所有动作都 happens-before 于其他线程从 Thread.join() 中成功返回。
这里特别说明一下，happens-before 规则不是描述实际操作的先后顺序，它是用来描述可见性的一种规则。

原文链接：https://blog.csdn.net/weixin_45476233/article/details/121558113



### double-checked lock问题

```java
package juc.jmm.pattern;

import lombok.extern.slf4j.Slf4j;

@Slf4j(topic = "singleton")
public class SingletonTest {
    private static SingletonTest INSTANTCE;

    /**
     * 尽可能缩小同步代码块范围
     */
    public static synchronized SingletonTest getSingleton() {
        if (INSTANTCE == null) {
            INSTANTCE = new SingletonTest();
        }
        return INSTANTCE;
    }

    /**
     * 相对上面的方法缩小了同步代码块，但是每次获取实例都需要加锁解锁
     */
    public static SingletonTest getSingleton2() {
        synchronized (SingletonTest.class) {
            if (INSTANTCE == null) {
                INSTANTCE = new SingletonTest();
            }
        }
        return INSTANTCE;
    }

    /**
     * 只有首次调用需要加锁，但因为第一个if判断在同步代码块外导致了一个非常隐蔽的问题，
     * 由于new SingletonTest()不是原子操作，执行时可能出现指令重排序的情况
     * 正常过程如下：
     * <p>
     * 1. 分配内存空间
     * 2. 初始化Singleton实例
     * 3. 赋值 instance 实例引用
     * <p>
     * 重排序以后可能会出现：
     * <p>
     * 1. 分配内存空间
     * 2. 赋值 instance 实例引用
     * 3. 初始化Singleton实例
     * 这样重排序并不影响单线程的执行结果，JVM是允许的。但是在多线程中就会出问题。
     * <p>
     * 当重排序以后，线程B 拿到了不为null 的instance实例引用，但是并没有被初始化，然后线程B使用了一个没有被初始化的对象引用，就出问题了。
     */
    public static SingletonTest getSingleton3() {
        if (INSTANTCE == null) {
            //synchronized不能防止指令重排序，重排序遵循"as-if-serial"原则
            //
            synchronized (SingletonTest.class) {
                if (INSTANTCE == null) {
                    INSTANTCE = new SingletonTest();
                }
            }
        }
        return INSTANTCE;
    }

    /**
     * 双重检测问题解决
     * 方案一
     * 内部类是懒加载，只有在第一次使用时才会初始化
     * 方案二
     * 添加volatile关键字
     */
    public static class InnerClass {
        public static final SingletonTest INSTANCE = new SingletonTest();
    }

    private SingletonTest() {

    }

}

```



假设有两个线程A、B，当线程A 执行到 instance = new Singleton(); 时，线程B执行到 if (instance == null)。这里如果正常，那就是 Singleton被新建，并赋值给 instance ，线程B 拿到instance时不为null，同时开始使用 instance。

由于 instance = new Singleton();的执行过程可能被重排序。

正常过程如下：

1. 分配内存空间
2. 初始化Singleton实例
3. 赋值 instance 实例引用

重排序以后可能会出现：

1. 分配内存空间
2. 赋值 instance 实例引用
3. 初始化Singleton实例

这样重排序并不影响单线程的执行结果，JVM是允许的。但是在多线程中就会出问题。

当重排序以后，线程B 拿到了不为null 的instance实例引用，但是并没有被初始化，然后线程B使用了一个没有被初始化的对象引用，就出问题了。

原文链接：https://blog.csdn.net/u013490280/article/details/108722926



## LongAdder原理

### 关键字段

```java
    /**
     * Table of cells. When non-null, size is a power of 2.
     */
    transient volatile Cell[] cells;

    /**
     * Base value, used mainly when there is no contention, but also as
     * a fallback during table initialization races. Updated via CAS.
     */
    transient volatile long base;

    /**
     * Spinlock (locked via CAS) used when resizing and/or creating Cells.
     * 1 表示加锁
     */
    transient volatile int cellsBusy;
```

cas锁

```java
@Slf4j(topic = "lockCas")
public class LockCas {

    /**
     * 0 表示无锁
     * 1 表示有锁
     */
    public final AtomicInteger lock = new AtomicInteger(0);

    public void lock() {
        do {
        } while (!lock.compareAndSet(0, 1));
    }

    public void unlock() {
        lock.set(0);
        log.debug("unlock...");
    }

    public static void main(String[] args) {
        LockCas lock = new LockCas();
        new Thread(() -> {
            log.debug("start...");
            lock.lock();

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }).start();

        new Thread(() -> {
            log.debug("start...");
            lock.lock();

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }).start();

    }
}
```



### 原理之伪共享

Cell为累加单元

```java
    // @sun.misc.Contended  防止缓存行伪共享
    @sun.misc.Contended 
    static final class Cell {
        volatile long value;
        Cell(long x) { value = x; }
        //最重要的方法，用cas方式进行累加
        final boolean cas(long cmp, long val) {
            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
        }
        //省略不重要代码
    }
```

因为CPU与内存的速度差异很大，需要预读取数据到缓存来提升效率

而缓存已缓存行为单位，每个缓存行对应着一块内存，一般是64bit，8个long

缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存中

CPU要保证数据的一致性，如果某个CPU核心更改了数据，其他CPU核心对应的整个缓存行必须失效。

![](\picture\longAdder原理.jpg)

![](\picture\longAdder原理2.jpg)

## Unsafe原理

```java
@Slf4j(topic = "unsafe")
public class UnsafeTest {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
        //Class com.hyh.cas.UnsafeTest can not access a member of class sun.misc.Unsafe with modifiers "private static final"
        theUnsafe.setAccessible(true);

        Unsafe unsafe = (Unsafe) theUnsafe.get(null);

        log.debug("unsafe={}", unsafe);

        //1. 获取域的偏移地址
        long idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField("id"));
        long nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField("name"));

        Teacher teacher = new Teacher();
        //2. 执行CAS操作
        log.debug("id cas = {}", unsafe.compareAndSwapInt(teacher, idOffset, 0, 1));
        log.debug("name cas = {}", unsafe.compareAndSwapObject(teacher, nameOffset, null, "hyh"));


    }
}

@Data
class Teacher {
    volatile String name;

    volatile int id;
}
```

## final原理

`final`原理对比`volatile`关键字就会非常好理解，

final变量写入操作后有一个写屏障（同步到主存），保证线程的可见性。

读取final变量时候，如果加了final则读取数值是在常量池中取数据，提高了效率

