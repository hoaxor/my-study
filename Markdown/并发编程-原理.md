# 并发编程-原理

## Volatile原理

### 内存屏障指令

为了实现 volatile 内存语义（即内存可见性），JMM 会限制特定类型的编译器和处理器重排序。为此，JMM 针对编译器制定了 volatile 重排序规则表，如下所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/ab7f14de806c48ffb73dcacbe62c3683.png)

使用 volatile 修饰变量时，根据 volatile 重排序规则表，Java 编译器在生成字节码时，会在指令序列中插入内存屏障指令来禁止特定类型的处理器重排序。

**内存屏障是一组处理器指令，它的作用是禁止指令重排序和解决内存可见性的问题。**

JMM 把内存屏障指令分为下列四类：

![在这里插入图片描述](https://img-blog.csdnimg.cn/5001ab2425d448a8b83e532e40868a51.png)

StoreLoad 屏障是一个全能型的屏障，它同时具有其他三个屏障的效果。所以执行该屏障开销会很大，因为它使处理器要把缓存中的数据全部刷新到内存中。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8dbeef0aef90405b953d426e98f2dcfd.png)

从上图，我们可以知道 volatile 读 / 写插入内存屏障规则：

在每个 volatile 读操作的后面插入 LoadLoad 屏障和 LoadStore 屏障。
在每个 volatile 写操作的前后分别插入一个 StoreStore 屏障和一个 StoreLoad 屏障。
也就是说，编译器不会对 volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与volatile 写前面的任意内存操作重排序。

### happens-before 概述

上面我们讲述了重排序原则，为了提高处理速度， JVM 会对代码进行编译优化，也就是指令重排序优化，但是并发编程下指令重排序也会带来一些安全隐患：如指令重排序导致的多个线程操作之间的不可见性。为了理解 JMM 提供的内存可见性保证，让程序员再去学习复杂的重排序规则以及这些规则的具体实现，那么程序员的负担就太重了，严重影响了并发编程的效率。

所以从 JDK5 开始，提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。

happens-before 规则如下：

程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。
监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。
volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。
传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。
start() 规则：Thread.start() 的调用会 happens-before 于启动线程里面的动作。
join() 规则：Thread 中的所有动作都 happens-before 于其他线程从 Thread.join() 中成功返回。
这里特别说明一下，happens-before 规则不是描述实际操作的先后顺序，它是用来描述可见性的一种规则。

原文链接：https://blog.csdn.net/weixin_45476233/article/details/121558113



### double-checked lock问题

```java
package juc.jmm.pattern;

import lombok.extern.slf4j.Slf4j;

@Slf4j(topic = "singleton")
public class SingletonTest {
    private static SingletonTest INSTANTCE;

    /**
     * 尽可能缩小同步代码块范围
     */
    public static synchronized SingletonTest getSingleton() {
        if (INSTANTCE == null) {
            INSTANTCE = new SingletonTest();
        }
        return INSTANTCE;
    }

    /**
     * 相对上面的方法缩小了同步代码块，但是每次获取实例都需要加锁解锁
     */
    public static SingletonTest getSingleton2() {
        synchronized (SingletonTest.class) {
            if (INSTANTCE == null) {
                INSTANTCE = new SingletonTest();
            }
        }
        return INSTANTCE;
    }

    /**
     * 只有首次调用需要加锁，但因为第一个if判断在同步代码块外导致了一个非常隐蔽的问题，
     * 由于new SingletonTest()不是原子操作，执行时可能出现指令重排序的情况
     * 正常过程如下：
     * <p>
     * 1. 分配内存空间
     * 2. 初始化Singleton实例
     * 3. 赋值 instance 实例引用
     * <p>
     * 重排序以后可能会出现：
     * <p>
     * 1. 分配内存空间
     * 2. 赋值 instance 实例引用
     * 3. 初始化Singleton实例
     * 这样重排序并不影响单线程的执行结果，JVM是允许的。但是在多线程中就会出问题。
     * <p>
     * 当重排序以后，线程B 拿到了不为null 的instance实例引用，但是并没有被初始化，然后线程B使用了一个没有被初始化的对象引用，就出问题了。
     */
    public static SingletonTest getSingleton3() {
        if (INSTANTCE == null) {
            //synchronized不能防止指令重排序，重排序遵循"as-if-serial"原则
            //
            synchronized (SingletonTest.class) {
                if (INSTANTCE == null) {
                    INSTANTCE = new SingletonTest();
                }
            }
        }
        return INSTANTCE;
    }

    /**
     * 双重检测问题解决
     * 方案一
     * 内部类是懒加载，只有在第一次使用时才会初始化
     * 方案二
     * 添加volatile关键字
     */
    public static class InnerClass {
        public static final SingletonTest INSTANCE = new SingletonTest();
    }

    private SingletonTest() {

    }

}

```



假设有两个线程A、B，当线程A 执行到 instance = new Singleton(); 时，线程B执行到 if (instance == null)。这里如果正常，那就是 Singleton被新建，并赋值给 instance ，线程B 拿到instance时不为null，同时开始使用 instance。

由于 instance = new Singleton();的执行过程可能被重排序。

正常过程如下：

1. 分配内存空间
2. 初始化Singleton实例
3. 赋值 instance 实例引用

重排序以后可能会出现：

1. 分配内存空间
2. 赋值 instance 实例引用
3. 初始化Singleton实例

这样重排序并不影响单线程的执行结果，JVM是允许的。但是在多线程中就会出问题。

当重排序以后，线程B 拿到了不为null 的instance实例引用，但是并没有被初始化，然后线程B使用了一个没有被初始化的对象引用，就出问题了。

原文链接：https://blog.csdn.net/u013490280/article/details/108722926



## LongAdder原理

关键字段

```java
    /**
     * Table of cells. When non-null, size is a power of 2.
     */
    transient volatile Cell[] cells;

    /**
     * Base value, used mainly when there is no contention, but also as
     * a fallback during table initialization races. Updated via CAS.
     */
    transient volatile long base;

    /**
     * Spinlock (locked via CAS) used when resizing and/or creating Cells.
     */
    transient volatile int cellsBusy;
```

