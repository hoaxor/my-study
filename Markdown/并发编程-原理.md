

# 并发编程-原理

## Volatile原理

### 内存屏障指令

为了实现 volatile 内存语义（即内存可见性），JMM 会限制特定类型的编译器和处理器重排序。为此，JMM 针对编译器制定了 volatile 重排序规则表，如下所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/ab7f14de806c48ffb73dcacbe62c3683.png)

使用 volatile 修饰变量时，根据 volatile 重排序规则表，Java 编译器在生成字节码时，会在指令序列中插入内存屏障指令来禁止特定类型的处理器重排序。

**内存屏障是一组处理器指令，它的作用是禁止指令重排序和解决内存可见性的问题。**

JMM 把内存屏障指令分为下列四类：

![在这里插入图片描述](https://img-blog.csdnimg.cn/5001ab2425d448a8b83e532e40868a51.png)

StoreLoad 屏障是一个全能型的屏障，它同时具有其他三个屏障的效果。所以执行该屏障开销会很大，因为它使处理器要把缓存中的数据全部刷新到内存中。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8dbeef0aef90405b953d426e98f2dcfd.png)

从上图，我们可以知道 volatile 读 / 写插入内存屏障规则：

在每个 volatile 读操作的后面插入 LoadLoad 屏障和 LoadStore 屏障。
在每个 volatile 写操作的前后分别插入一个 StoreStore 屏障和一个 StoreLoad 屏障。
也就是说，编译器不会对 volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与volatile 写前面的任意内存操作重排序。

### happens-before 概述

上面我们讲述了重排序原则，为了提高处理速度， JVM 会对代码进行编译优化，也就是指令重排序优化，但是并发编程下指令重排序也会带来一些安全隐患：如指令重排序导致的多个线程操作之间的不可见性。为了理解 JMM 提供的内存可见性保证，让程序员再去学习复杂的重排序规则以及这些规则的具体实现，那么程序员的负担就太重了，严重影响了并发编程的效率。

所以从 JDK5 开始，提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。

happens-before 规则如下：

程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。
监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。
volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。
传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。
start() 规则：Thread.start() 的调用会 happens-before 于启动线程里面的动作。
join() 规则：Thread 中的所有动作都 happens-before 于其他线程从 Thread.join() 中成功返回。
这里特别说明一下，happens-before 规则不是描述实际操作的先后顺序，它是用来描述可见性的一种规则。

原文链接：https://blog.csdn.net/weixin_45476233/article/details/121558113



### double-checked lock问题

```java
package juc.jmm.pattern;

import lombok.extern.slf4j.Slf4j;

@Slf4j(topic = "singleton")
public class SingletonTest {
    private static SingletonTest INSTANTCE;

    /**
     * 尽可能缩小同步代码块范围
     */
    public static synchronized SingletonTest getSingleton() {
        if (INSTANTCE == null) {
            INSTANTCE = new SingletonTest();
        }
        return INSTANTCE;
    }

    /**
     * 相对上面的方法缩小了同步代码块，但是每次获取实例都需要加锁解锁
     */
    public static SingletonTest getSingleton2() {
        synchronized (SingletonTest.class) {
            if (INSTANTCE == null) {
                INSTANTCE = new SingletonTest();
            }
        }
        return INSTANTCE;
    }

    /**
     * 只有首次调用需要加锁，但因为第一个if判断在同步代码块外导致了一个非常隐蔽的问题，
     * 由于new SingletonTest()不是原子操作，执行时可能出现指令重排序的情况
     * 正常过程如下：
     * <p>
     * 1. 分配内存空间
     * 2. 初始化Singleton实例
     * 3. 赋值 instance 实例引用
     * <p>
     * 重排序以后可能会出现：
     * <p>
     * 1. 分配内存空间
     * 2. 赋值 instance 实例引用
     * 3. 初始化Singleton实例
     * 这样重排序并不影响单线程的执行结果，JVM是允许的。但是在多线程中就会出问题。
     * <p>
     * 当重排序以后，线程B 拿到了不为null 的instance实例引用，但是并没有被初始化，然后线程B使用了一个没有被初始化的对象引用，就出问题了。
     */
    public static SingletonTest getSingleton3() {
        if (INSTANTCE == null) {
            //synchronized不能防止指令重排序，重排序遵循"as-if-serial"原则
            //
            synchronized (SingletonTest.class) {
                if (INSTANTCE == null) {
                    INSTANTCE = new SingletonTest();
                }
            }
        }
        return INSTANTCE;
    }

    /**
     * 双重检测问题解决
     * 方案一
     * 内部类是懒加载，只有在第一次使用时才会初始化
     * 方案二
     * 添加volatile关键字
     */
    public static class InnerClass {
        public static final SingletonTest INSTANCE = new SingletonTest();
    }

    private SingletonTest() {

    }

}

```



假设有两个线程A、B，当线程A 执行到 instance = new Singleton(); 时，线程B执行到 if (instance == null)。这里如果正常，那就是 Singleton被新建，并赋值给 instance ，线程B 拿到instance时不为null，同时开始使用 instance。

由于 instance = new Singleton();的执行过程可能被重排序。

正常过程如下：

1. 分配内存空间
2. 初始化Singleton实例
3. 赋值 instance 实例引用

重排序以后可能会出现：

1. 分配内存空间
2. 赋值 instance 实例引用
3. 初始化Singleton实例

这样重排序并不影响单线程的执行结果，JVM是允许的。但是在多线程中就会出问题。

当重排序以后，线程B 拿到了不为null 的instance实例引用，但是并没有被初始化，然后线程B使用了一个没有被初始化的对象引用，就出问题了。

原文链接：https://blog.csdn.net/u013490280/article/details/108722926



## LongAdder原理

### 关键字段

```java
    /**
     * Table of cells. When non-null, size is a power of 2.
     */
    transient volatile Cell[] cells;

    /**
     * Base value, used mainly when there is no contention, but also as
     * a fallback during table initialization races. Updated via CAS.
     */
    transient volatile long base;

    /**
     * Spinlock (locked via CAS) used when resizing and/or creating Cells.
     * 1 表示加锁
     */
    transient volatile int cellsBusy;
```

cas锁

```java
@Slf4j(topic = "lockCas")
public class LockCas {

    /**
     * 0 表示无锁
     * 1 表示有锁
     */
    public final AtomicInteger lock = new AtomicInteger(0);

    public void lock() {
        do {
        } while (!lock.compareAndSet(0, 1));
    }

    public void unlock() {
        lock.set(0);
        log.debug("unlock...");
    }

    public static void main(String[] args) {
        LockCas lock = new LockCas();
        new Thread(() -> {
            log.debug("start...");
            lock.lock();

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }).start();

        new Thread(() -> {
            log.debug("start...");
            lock.lock();

            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }).start();

    }
}
```



### 原理之伪共享

Cell为累加单元

```java
    // @sun.misc.Contended  防止缓存行伪共享
    @sun.misc.Contended 
    static final class Cell {
        volatile long value;
        Cell(long x) { value = x; }
        //最重要的方法，用cas方式进行累加
        final boolean cas(long cmp, long val) {
            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
        }
        //省略不重要代码
    }
```

因为CPU与内存的速度差异很大，需要预读取数据到缓存来提升效率

而缓存已缓存行为单位，每个缓存行对应着一块内存，一般是64bit，8个long

缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存中

CPU要保证数据的一致性，如果某个CPU核心更改了数据，其他CPU核心对应的整个缓存行必须失效。

![](\picture\longAdder原理.jpg)

![](\picture\longAdder原理2.jpg)

## Unsafe原理

```java
@Slf4j(topic = "unsafe")
public class UnsafeTest {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
        //Class com.hyh.cas.UnsafeTest can not access a member of class sun.misc.Unsafe with modifiers "private static final"
        theUnsafe.setAccessible(true);

        Unsafe unsafe = (Unsafe) theUnsafe.get(null);

        log.debug("unsafe={}", unsafe);

        //1. 获取域的偏移地址
        long idOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField("id"));
        long nameOffset = unsafe.objectFieldOffset(Teacher.class.getDeclaredField("name"));

        Teacher teacher = new Teacher();
        //2. 执行CAS操作
        log.debug("id cas = {}", unsafe.compareAndSwapInt(teacher, idOffset, 0, 1));
        log.debug("name cas = {}", unsafe.compareAndSwapObject(teacher, nameOffset, null, "hyh"));


    }
}

@Data
class Teacher {
    volatile String name;

    volatile int id;
}
```

## final原理

`final`原理对比`volatile`关键字就会非常好理解，

final变量写入操作后有一个写屏障（同步到主存），保证线程的可见性。

读取final变量时候，如果加了final则读取数值是在常量池中取数据，提高了效率



## AQS原理

全称是`AbstractQueuedSynchronizer`，是阻塞式锁和相关同步器工具的框架



特点：

- 用state属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取和释放锁
  - `getState`获取`state`
  - `setState`设置`state`
  - compareAndSetState乐观锁机制设置state
  - 独占模式是一个线程能够访问资源，共享模式可以允许多个线程访问资源

- 提供了`FIFO`的等待队列，类似于`Monitor`的`EntryList`
- 条件变量实现等待、唤醒机制，支持多个条件变量，类似`Monitor`的`WaitSet`



子类主要实现这样一些方法，默认抛出`UnsupportedOperationException`

- tryAcquire
- tryRelease
- tryAcquireShared
- tryReleaseShared
- isHeldExclusively

```java
package com.hyh.jucutil.threadpool.aqs;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

@Slf4j(topic = "aqsTest")
public class AQSTest {
    public static void main(String[] args) {
//        ReentrantLock reentrantLock = new ReentrantLock();
//        reentrantLock.lock();
        MyLock lock = new MyLock();
        new Thread(() -> {
            lock.lock();
            log.debug("locked...");
            //不可重入，会阻塞住
            //重复加锁会阻塞
//            lock.lock();
//            log.debug("locked...");
            try {
                log.debug("running...");
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                log.debug("unlocking...");
                lock.unlock();
            }
        }, "t1").start();

        new Thread(() -> {
            lock.lock();
            try {
                log.debug("running...");
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                log.debug("unlocking...");
                lock.unlock();
            }
        }, "t2").start();

    }
}

/**
 * 自定义锁，不可重入 独占式
 */
class MyLock implements Lock {

    public MySync sync;

    public MyLock() {
        sync = new MySync();
    }

    /**
     * 加锁
     */
    @Override
    public void lock() {
        sync.acquire(1);
    }

    /**
     * 可打断地加锁
     */
    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    /**
     * 尝试加锁
     */
    @Override
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    /**
     * 有超时时间的尝试加锁
     */
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(time));
    }

    /**
     * 解锁
     */
    @Override
    public void unlock() {
        sync.release(1);
    }

    /**
     * 新的条件变量
     */
    @Override
    public Condition newCondition() {
        return sync.newCondition();
    }

    static class MySync extends AbstractQueuedSynchronizer {

        @Override
        protected boolean tryAcquire(int arg) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            setExclusiveOwnerThread(null);
            //state 是volatile变量，写操作后会将前面涉及写操作的变量同步到主存
            setState(0);
            return true;
        }

        /**
         * 共享模式需要实现次方法
         */
        @Override
        protected int tryAcquireShared(int arg) {
            return super.tryAcquireShared(arg);
        }

        /**
         * 共享模式需要实现次方法
         */
        @Override
        protected boolean tryReleaseShared(int arg) {
            return super.tryReleaseShared(arg);
        }

        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        public Condition newCondition() {
            return new ConditionObject();
        }
    }
}

```



## ReentrantLock原理

### ![image-20220418232028225](\picture\image-20220418232028225.png)1. 非公平锁实现原理

#### 加锁解锁流程

ReentrantLock默认使用非公平锁

```java
    /**
     * Creates an instance of {@code ReentrantLock}.
     * This is equivalent to using {@code ReentrantLock(false)}.
     */
    public ReentrantLock() {
        sync = new NonfairSync();
    }
```

NonfairSync继承自AQS

没有竞争时

![image-20220419215752575](\picture\image-20220419215752575.png)

第一个竞争出现时

![image-20220419215810072](\picture\image-20220419215810072.png)

1. `Thread-1`做`CAS`，尝试将`state`由`0`改为`1`，结果失败了

2. 进入`tryAcquire`，这时`state`已经是`1`，结果仍然是失败

3. 接着进入`addWaiter`逻辑，构造`Node`队列，

   - 下图中黄色三角表示`Node`的`waitStatus`状态，其中`0`为默认正常状态
   - `Node`的创建是懒惰的
   - 其中的第一个`Node`称为哨兵或哑元（Dummy）即head，用来占位，并不关联线程

   ![image-20220419220633601](\picture\image-20220419220633601.png)

4. 接着进入`acquireQueued`

   - 死循环中不断尝试获得锁，失败后进入`park`阻塞

   - 如果自己排在`head`的后面（排第二），那么再次`tryAcquire`尝试获取锁

     - 加锁失败时，进入`shouldParkAfterFailedAcquire`，将前驱`node`（此时前驱为`head`）的`waitStatus`改为`-1`，这次返回`false`

       ![image-20220419222818933](\picture\image-20220419222818933.png)

     - 返回`acquireQueued`，重复上述逻辑，这时因为前驱`node`的`waitStatus`已经是`-1`，这次返回`true`
     - 进入`parkAndCheckInterrupt`，`Thread-1`进入`park`状态（灰色表示）

     ![image-20220419223401098](\picture\image-20220419223401098.png)

5. 若`Thread-0`不释放锁，此时有多个线程竞争，变成以下状态

![image-20220419223714502](\picture\image-20220419223714502.png)

6. `Thread-0`释放锁，进入`tryRelease`流程，如果成功

- 设置`exclusiveOwnerThread`为`null`
- 设置`state`状态为`0`

![image-20220419224808668](\picture\image-20220419224808668.png)

7. 当`head`不为`null`，并且`head`的`waitStatus=-1`，进入`unparkSuccessor`

8. 先找`head`的下一个`node`，若此`node`的`waitStauts`为`0`则`unparknode`持有的线程（本例中即为`Thread-1`）

9. `Thread-1`恢复，继续执行`acquireQueued`，通过`tryAcquire`尝试获取锁，

   - 若被其他线程先成功获取锁，假设新来了一个线程`Thread-4`（非公平的体现）
     - `Thread-4`被设置为`exclusiveOwnerThread`，state`设置`为`1`
     - `Thread-1`再次进入`acquireQueued`，获取锁失败，重新进入`park`阻塞

   - 若此时没有竞争成功获得锁则修改`head`为成功获得锁的`node`，见下述代码，原来的`head`从链表中断开（可被GC）

```java
    private void setHead(Node node) {
        head = node;
        node.thread = null;
        node.prev = null;
    }
```

### 2. 可重入原理

```java
        /**
         * lock.lock()->sync.lock()->sync.acquire(1)->sync.tryAcquire(1)->sync.nonfairTryAcquire(1)
         * tryAcquire会调用此方法尝试获取锁
         * Performs non-fair tryLock.  tryAcquire is implemented in
         * subclasses, but both need nonfair try for trylock method.
         */
        final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                //使用CAS尝试获取锁，这里体现了非公平性，不去检查AQS队列
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            //如果已经获得锁则current == getExclusiveOwnerThread()为true，表明发生了锁重入
            else if (current == getExclusiveOwnerThread()) {
                //state++并校验获取锁的次数是否溢出
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
       
        /*
        * lock.unlock()->sync.release(1)->tryRelease(1)
        * 
        */
        protected final boolean tryRelease(int releases) {
            //state--
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            //只有state==0表明所有重入锁都已释放，
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
```



### 3. 可打断原理

#### 不可打断模式

此模式下，即使被打断，仍会驻留在AQS队列中，等获得锁后方能继续运行（继续运行，打断标记设为true）

```java
    /**
     * Acquires in exclusive uninterruptible mode for thread already in
     * queue. Used by condition wait methods as well as acquire.
     *
     * @param node the node
     * @param arg the acquire argument
     * @return {@code true} if interrupted while waiting
     */
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    //获得锁返回打断标记
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    /**
     * Convenience method to park and then check if interrupted
     *
     * @return {@code true} if interrupted
     */
    private final boolean parkAndCheckInterrupt() {
        //打断标记为true时或park后其它线程调用线程的interrupt()，park会失效
        LockSupport.park(this);
        //interrupted会清除打断标记
        return Thread.interrupted();
    }

    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            // acquireQueued返回的打断标记为true时进入selfInterrupt
            selfInterrupt();
    }

    /**
     * Convenience method to interrupt current thread.
     */
    static void selfInterrupt() {
        //自己打断自己
        Thread.currentThread().interrupt();
    }

```

#### 可打断模式



```java
    /**
     * Acquires in exclusive mode, aborting if interrupted.
     * Implemented by first checking interrupt status, then invoking
     * at least once {@link #tryAcquire}, returning on
     * success.  Otherwise the thread is queued, possibly repeatedly
     * blocking and unblocking, invoking {@link #tryAcquire}
     * until success or the thread is interrupted.  This method can be
     * used to implement method {@link Lock#lockInterruptibly}.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     * @throws InterruptedException if the current thread is interrupted
     */
    public final void acquireInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (!tryAcquire(arg))
            // 没有获得锁进入可打断流程
            doAcquireInterruptibly(arg);
    }

    /**
     * Acquires in exclusive interruptible mode.
     * @param arg the acquire argument
     */
    private void doAcquireInterruptibly(int arg)
        throws InterruptedException {
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    //被打断时直接抛出被打断异常
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```





### 2. 公平锁实现原理

与公平锁的主要区别在于`tryAcquire`,尝试获取锁之前会检查AQS

```java
    final void lock() {
        acquire(1);
    }

    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
        /**
         * Fair version of tryAcquire.  Don't grant access unless
         * recursive call or no waiters or is first.
         */
        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                //获取锁之前检查AQS队列
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
    }
    /**
     * Queries whether any threads have been waiting to acquire longer
     * than the current thread.
     *
     * <p>An invocation of this method is equivalent to (but may be
     * more efficient than):
     *  <pre> {@code
     * getFirstQueuedThread() != Thread.currentThread() &&
     * hasQueuedThreads()}</pre>
     *
     * <p>Note that because cancellations due to interrupts and
     * timeouts may occur at any time, a {@code true} return does not
     * guarantee that some other thread will acquire before the current
     * thread.  Likewise, it is possible for another thread to win a
     * race to enqueue after this method has returned {@code false},
     * due to the queue being empty.
     *
     * <p>This method is designed to be used by a fair synchronizer to
     * avoid <a href="AbstractQueuedSynchronizer#barging">barging</a>.
     * Such a synchronizer's {@link #tryAcquire} method should return
     * {@code false}, and its {@link #tryAcquireShared} method should
     * return a negative value, if this method returns {@code true}
     * (unless this is a reentrant acquire).  For example, the {@code
     * tryAcquire} method for a fair, reentrant, exclusive mode
     * synchronizer might look like this:
     *
     *  <pre> {@code
     * protected boolean tryAcquire(int arg) {
     *   if (isHeldExclusively()) {
     *     // A reentrant acquire; increment hold count
     *     return true;
     *   } else if (hasQueuedPredecessors()) {
     *     return false;
     *   } else {
     *     // try to acquire normally
     *   }
     * }}</pre>
     *
     * @return {@code true} if there is a queued thread preceding the
     *         current thread, and {@code false} if the current thread
     *         is at the head of the queue or the queue is empty
     * @since 1.7
     */
    public final boolean hasQueuedPredecessors() {
        // The correctness of this depends on head being initialized
        // before tail and on head.next being accurate if the current
        // thread is first in queue.
        Node t = tail; // Read fields in reverse initialization order
        Node h = head;
        Node s;
        //h != t 表示队列中没有node
        return h != t &&
            //(s = h.next) == null表示队列中没有等待获取锁的节点，只有哨兵
            //队列中有节点但当前线程不是队列中的第一个节点
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }

```



## 条件变量原理

每个条件变量其实就对应着一个等待队列，其实现类是`ConditionObject`

### await流程

开始`Thread-0`持有锁，调用`await`，进入`addConditionWaiter`，创建新的`Node`，`waitStauts`初始为为`-2`（Node.CONDITION）,关联`Thread-0`，加入等待队列尾部（FIFO单向链表）

![image-20220420224707423](\picture\image-20220420224707423.png)

接下来进入`AQS`的fullyRelease，首先会检查是否获得了锁，否则会抛出`IllegalMonitorStateException`（因可能发生了锁重入，要把所有的锁都释放掉），然后释放同步器上的锁

![image-20220420224949574](\picture\image-20220420224949574.png)

`upark` `AQS`队列中的下一个节点，竞争锁，假设没有竞争，那么`Thread-1`成功获得锁

![image-20220420230305080](\picture\image-20220420230305080.png)

`park`阻塞`Thread-0`

![image-20220420230342545](\picture\image-20220420230342545.png)



### signal流程

假设`Thread-1`要来唤醒`Thread-0`

![image-20220420230445470](\picture\image-20220420230445470.png)

进入`doSignal`，首先检查是否获得了锁，然后再`condition`的链表中找第一个`Node`即`firstWaiter`

![image-20220420230833664](\picture\image-20220420230833664.png)

执行`transferForSignal`，将该`Node`加入`AQS`队列尾部，将`Thread-0`的`waitStatus`改为`0`，`Thread-1`的`waitStatus`改为`-1`

![image-20220420232730372](\picture\image-20220420232730372.png)

`Thread-1`释放锁进入`unlock`。



## ReentrantReadWriteLock原理

### 读写锁原理

读写锁用到的是同一个`AQS`同步器，因此等待队列、state等都是同一个

t1 w.lock，t2 r.lock

![image-20220425220059186](\picture\image-20220425220059186.png)

读锁

![image-20220425220522535](\picture\image-20220425220522535.png)

![image-20220425221016397](D:\myCode\my-study\Markdown\picture\image-20220425221016397.png)

![image-20220425221234479](\picture\image-20220425221234479.png)

![image-20220425221334680](\picture\image-20220425221334680.png)

![image-20220425221409995](\picture\image-20220425221409995.png)

![image-20220425221514898](\picture\image-20220425221514898.png)

![image-20220425221754642](\picture\image-20220425221754642.png)![image-20220425221955355](\picture\image-20220425221955355.png)

![image-20220425222645183](\picture\image-20220425222645183.png)

![image-20220425222931629](\picture\image-20220425222931629.png)

![image-20220425223025061](\picture\image-20220425223025061.png)

t4不是sharedNode，不会被唤醒

![image-20220425223221769](\picture\image-20220425223221769.png)

![image-20220425223535592](\picture\image-20220425223535592.png)

![image-20220425223631291](\picture\image-20220425223631291.png)

## Semaphore原理

### 1.加锁解锁原理

![image-20220426223211713](\picture\image-20220426223211713.png)

![image-20220426223416919](\picture\image-20220426223416919.png)

![image-20220426224233681](\picture\image-20220426224233681.png)![image-20220426224502021](\picture\image-20220426224502021.png)

## ConcurrentHashMap原理

### JDK7 HashMap并发死链

JDK7中HashMap旧数组迁移到新数组采用**头插法**，这样会导致新链表元素的逆序排列

多线程并发扩容的情况下，链表可能形成死链。一旦有查找元素的动作，线程将会进入死循环，从而引发CPU使用率飙升

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200331221945214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDA0Mzk1,size_16,color_FFFFFF,t_70)

```java
package org.hyh.map;

import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;

/**
 * jdk1.7
 *
 * @author : huang.yaohua
 * @date : 2022/5/1 21:38
 */
@Slf4j(topic = "hashMapTest")
public class HashMapTest {
    public static void main(String[] args) throws InterruptedException {
        // 什么情况下触发死链 infinite loop
        final HashMap<MyKey, String> map = new HashMap<>(1);
        MyKey key = new MyKey();
        map.put(key, "1");
        map.put(new MyKey(), "2");

        //map 初始为 2-1
        //使map达到扩容条件
        //需使用调试模式触发死链
        //t1、t2同时触发扩容操作
        //t1 停在transfer Entry<K,V> next = e.next;代码后 , 此时 e 为 2 next 为 1
        //t2 先完成扩容操作 map变为 4-1-2
        //t1 继续扩容，2.next指向 newTable[i] 把 2放到 newTable[i]链表首个位置，e 赋值为 1
        // e 此时变为为 1
        // 重复上一步操作，1.next指向2，1放到newTable[i]链表首个位置， e赋值为 next,由于t2已经修改了1.next指向2所以 e被赋值为2
        // 重复上一步操作，由于2.next=null所以扩容正常退出
        // table = newTable
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                map.put(new MyKey(), "3");
            }
        }, "t1");
        t1.start();

        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                map.put(new MyKey(), "4");
            }
        }, "t2");
        t2.start();
        t1.join();
        t2.join();
        //由于map中已经形成死链，1-2-1，查找不存在的key会使查找进入死循环
        System.out.println(map.get(new MyKey()));
    }
}

class MyKey {
    /*hashCode 的常规协定是：
    在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，
    前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。
    如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。
    以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。
    实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。
    （这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）
    当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。*/
    @Override
    public int hashCode() {
        //使得所有key都落在同一桶中
        return 1;
    }

    @Override
    public boolean equals(Object obj) {
        return super.equals(obj);
    }

}

```

DK1.8 `HashMap` 底层结构进行彻底重构，使用`数组`加`链表/红黑树`方式这种组合结构。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200331223350671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDA0Mzk1,size_16,color_FFFFFF,t_70)

新元素依旧通过取模方式获取 Table 数组位置，然后再将元素加入链表尾部。一旦链表元素数量超过 8 之后，自动转为红黑树，进一步提高了查找效率。

由于 JDK1.8 链表采用尾插入法，从而避免并发扩容情况下链表形成死链的可能。

但是HashMap在JDK1.8仍然不适合用于并发场景，依然是无法避免并发扩容情况下的死链问题。（并发赋值时被覆盖、size 计算问题）

原文链接：https://blog.csdn.net/qq_33404395/article/details/105233302

### JDK8 ConcurrentHashMap

#### 重要属性和内部类

```java
    /**
     * 默认为0
     * 当初始化时为-1
     * 当扩容时，为-(1+扩容线程数)
     * 当扩容完成后，为下一次的扩容的阈值大小
     */
    private transient volatile int sizeCtl;
    /**
     * The array of bins. Lazily initialized upon first insertion.
     * Size is always a power of two. Accessed directly by iterators.
     */
    transient volatile Node<K,V>[] table;
    /**
     * The next table to use; non-null only while resizing.
     */
    private transient volatile Node<K,V>[] nextTable;

    /**
     * Key-value entry.  This class is never exported out as a
     * user-mutable Map.Entry (i.e., one supporting setValue; see
     * MapEntry below), but can be used for read-only traversals used
     * in bulk tasks.  Subclasses of Node with a negative hash field
     * are special, and contain null keys and values (but are never
     * exported).  Otherwise, keys and vals are never null.
     */
    static class Node<K,V> implements Map.Entry<K,V> {}
    /**
     * A node inserted at head of bins during transfer operations.
     * 扩容时，如果某个bin迁移完毕，用ForwardingNode作为旧talbe bins的头节点
     */
    static final class ForwardingNode<K,V> extends Node<K,V> {}
    /**
     * A place-holder node used in computeIfAbsent and compute
     */
    static final class ReservationNode<K,V> extends Node<K,V> {}
    /**
     * TreeNodes used at the heads of bins. TreeBins do not hold user
     * keys or values, but instead point to list of TreeNodes and
     * their root. They also maintain a parasitic read-write lock
     * forcing writers (who hold bin lock) to wait for readers (who do
     * not) to complete before tree restructuring operations.
     * 作为treebin的头节点，存储root和first
     */
    static final class TreeBin<K,V> extends Node<K,V> {}
    /**
     * Nodes for use in TreeBins
     * 作为treebin的节点，存储parent、left、right
     */
    static final class TreeNode<K,V> extends Node<K,V> {}


```

#### 重要方法

```java
    //获取tab中第i个node
    static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {
        return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);
    }
    //cas 修改tab中第i个元素的值，c为旧值，v为新值
    static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i,
                                        Node<K,V> c, Node<K,V> v) {
        return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);
    }
    // 直接修改修改tab中第i个元素的值， v为新值
    static final <K,V> void setTabAt(Node<K,V>[] tab, int i, Node<K,V> v) {
        U.putObjectVolatile(tab, ((long)i << ASHIFT) + ABASE, v);
    }
```

##### 构造器

使用了懒惰初始化，构造方法中仅仅计算了table的大小，会在第一次使用时才会真正创建

```java
    public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
            throw new IllegalArgumentException();
        if (initialCapacity < concurrencyLevel)   // Use at least as many bins
            initialCapacity = concurrencyLevel;   // as estimated threads
        long size = (long)(1.0 + (long)initialCapacity / loadFactor);
        int cap = (size >= (long)MAXIMUM_CAPACITY) ?
            MAXIMUM_CAPACITY : tableSizeFor((int)size);
        this.sizeCtl = cap;
    }
```

##### get

```java
    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * <p>More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code key.equals(k)},
     * then this method returns {@code v}; otherwise it returns
     * {@code null}.  (There can be at most one such mapping.)
     *
     * @throws NullPointerException if the specified key is null
     */
    public V get(Object key) {
        Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
        //spread 方法能确保返回结果是正数
        int h = spread(key.hashCode());
        if ((tab = table) != null && (n = tab.length) > 0 &&
            // (n - 1) & h) 相当于取模运算，只有2的n次方
            (e = tabAt(tab, (n - 1) & h)) != null) {
            //如果头节点是要找的key
            if ((eh = e.hash) == h) {
                if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                    return e.val;
            }
            // hash为负数表示该bin在扩容中或是treebin，这时调用find方法来查找
            else if (eh < 0)
                return (p = e.find(h, key)) != null ? p.val : null;
            //正序遍历链表，用equals比较
            while ((e = e.next) != null) {
                if (e.hash == h &&
                    ((ek = e.key) == key || (ek != null && key.equals(ek))))
                    return e.val;
            }
        }
        return null;
    }
```

##### put

当数组大小已经超过64并且链表中的元素个数超过默认设定（8个）时，将链表转化为红黑树

```java
    /**
     * Maps the specified key to the specified value in this table.
     * Neither the key nor the value can be null.
     *
     * <p>The value can be retrieved by calling the {@code get} method
     * with a key that is equal to the original key.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with {@code key}, or
     *         {@code null} if there was no mapping for {@code key}
     * @throws NullPointerException if the specified key or value is null
     */
    public V put(K key, V value) {
        return putVal(key, value, false);
    }

    /** 
    * Implementation for put and putIfAbsent 
    * onlyIfAbsent 为false时，当map中存在相同的key，会用新值覆盖旧值
    * 为true时，不会覆盖
    */
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        // spread方法会综合高低位，(h ^ (h >>> 16)) & 0x7fffffff;
        int hash = spread(key.hashCode());
        //链表长度
        int binCount = 0;
        for (Node<K,V>[] tab = table;;) {
            //f是链表头节点
            //fh是链表头节点的hash
            //i是链表在table中的下标
            Node<K,V> f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                //table未初始化，初始化table。使用CAS方式，未加锁
                //table初始化成功，进入下一轮循环
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                //不存在头节点
                //创建头节点，使用CAS方式
                if (casTabAt(tab, i, null,
                             new Node<K,V>(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                //头节点hash == -1 表示正在扩容，进入帮助扩容逻辑，完成之后进入下一轮循环
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                // 锁住链表头节点
                synchronized (f) {
                    // 再次确认头节点没有被移到
                    if (tabAt(tab, i) == f) {
                        //是链表 链表头节点的hash大于0
                        if (fh >= 0) {
                            binCount = 1;
                            //遍历链表
                            for (Node<K,V> e = f;; ++binCount) {
                                K ek;
                                // 找到了相同的key hash相等且（key地址相等或equals）
                                if (e.hash == hash &&
                                    ((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) {
                                    oldVal = e.val;
                                    //onlyIfAbsent=false时更新
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node<K,V> pred = e;
                                // 遍历到链表中最后一个节点，新增Node，加到链表尾部
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        //是红黑树
                        else if (f instanceof TreeBin) {
                            Node<K,V> p;
                            binCount = 2;
                            //putTreeVal会查找红黑树中是否已经存在此key，存在则返回对应的TreeNode
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    // TREEIFY_THRESHOLD 8
                    if (binCount >= TREEIFY_THRESHOLD)
                        // 如果链表长度超过树化阈值，将链表转为红黑树
                        // 不一定会转化为红黑树
                        // 如果当前数组长度小于64 ，那么会对数组进行扩容，而不是转化为红黑树
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        // 增加size计数
        addCount(1L, binCount);
        return null;
    }

    /**
     * Initializes table, using the size recorded in sizeCtl.
     */
    private final Node<K,V>[] initTable() {
        Node<K,V>[] tab; int sc;
        while ((tab = table) == null || tab.length == 0) {
            if ((sc = sizeCtl) < 0)
                // 初始化竞争失败，一直循环直到tab成功初始化
                Thread.yield(); // lost initialization race; just spin
            // 尝试将sizeCtl设置为-1（-1表示初始化）
            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                // CAS 成功，创建table
                try {
                    if ((tab = table) == null || tab.length == 0) {
                        // 如果使用了带初始容量的构造器，会使用构造器提供的
                        // 否则使用默认容量
                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                        @SuppressWarnings("unchecked")
                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                        table = tab = nt;
                        // 相当于 0.75 * n
                        sc = n - (n >>> 2);
                    }
                } finally {
                    // 从 -1 还原成阈值
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }

    /**
     * Adds to count, and if table is too small and not already
     * resizing, initiates transfer. If already resizing, helps
     * perform transfer if work is available.  Rechecks occupancy
     * after a transfer to see if another resize is already needed
     * because resizings are lagging additions.
     *
     * @param x the count to add
     * @param check if <0, don't check resize, if <= 1 only check if uncontended
     * x 表示这次需要在表中增加的元素个数，check 参数表示是否需要进行扩容检查，这里传的是链表的长度
     */
    private final void addCount(long x, int check) {
        CounterCell[] as; long b, s;
        // 已经有了counterCells 或 还没有counterCells，向baseCount累加
        // 检查counterCells 是否为空
        // 如果counterCells 为空 通过 cas 操作尝试修改 baseCount 变量，对这个变量进行原子累加操作
        // 做这个操作的	意义是:如果在没有竞争的情况下，仍然采用 baseCount 来记录元素个数
  	    // 如果 cas 失败说明存在竞争，这个时候不能再采用 baseCount 来累加，而是通过
		// CounterCell 来记录
        // 原文链接：https://blog.csdn.net/a15835774652/article/details/121431340
        if ((as = counterCells) != null ||
            !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
            CounterCell a; long v; int m;
            // 是否冲突，默认没有冲突
            boolean uncontended = true;
            // 没有counterCells 或 counterCells长度为0 或 cell CAS增加计数失败
            // 随机值&countCells长度 作为索引 在countCells数组上为空 
            // 通过 CAS 修改 CounterCell 随机位置的值，如果修改失败说明出现并发情况调用 fullAndCount
            // Random 在线程并发的时候会有性能问题以及可能会产生相同的随机数,
            // ThreadLocalRandom.getProbe 可以解决这个问题，并且性能要比 Random 高
            if (as == null || (m = as.length - 1) < 0 ||
                (a = as[ThreadLocalRandom.getProbe() & m]) == null ||
                !(uncontended =
                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
                // 创建累加单元数据和cell, 累加重试
                fullAddCount(x, uncontended);
                return;
            }
            //链表长度小于等于1
            if (check <= 1)
                return;
            // 获取元素个数
            s = sumCount();
        }
        if (check >= 0) {
            Node<K,V>[] tab, nt; int n, sc;
            // 元素个大于阈值
            while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
                   (n = tab.length) < MAXIMUM_CAPACITY) {
                int rs = resizeStamp(n);
                if (sc < 0) {
                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                        transferIndex <= 0)
                        break;
                    // newTable已经创建，帮助转移
                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                        transfer(tab, nt);
                }
                else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                             (rs << RESIZE_STAMP_SHIFT) + 2))
                    // newTable未创建，帮助转移
                    transfer(tab, null);
                s = sumCount();
            }
        }
    }

    // See LongAdder version for explanation
    private final void fullAddCount(long x, boolean wasUncontended) {
        int h;
        if ((h = ThreadLocalRandom.getProbe()) == 0) {
            // 随机数为零，强制初始化
            ThreadLocalRandom.localInit();      // force initialization
            // 重新获取随机数
            h = ThreadLocalRandom.getProbe();
            // 由于重新生成了probe，未冲突标志位设置为true
            wasUncontended = true;
        }
        boolean collide = false;                // True if last slot nonempty
        for (;;) {
            CounterCell[] as; CounterCell a; int n; long v;
            // counterCells 不为null且长度大于0
            if ((as = counterCells) != null && (n = as.length) > 0) {
                // 通过该值与当前线程 probe 求与，获得 cells 的下标元素，和 hash 表获取索引是一样的
                if ((a = as[(n - 1) & h]) == null) {
                    // cells对应的索引位置为空
                    if (cellsBusy == 0) {            // Try to attach new Cell
                        // cellsBusy=0 表示 counterCells 不在初始化或者扩容状态下
                        // 构造一个CounterCell的值 并传入元素的个数
                        CounterCell r = new CounterCell(x); // Optimistic create
                        // cas 设置cells 标记为1  表示已经有线程在处理
                        if (cellsBusy == 0 &&
                            U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                            boolean created = false;
                            try {               // Recheck under lock
                                CounterCell[] rs; int m, j;
                                // 重新检测
                                if ((rs = counterCells) != null &&
                                    (m = rs.length) > 0 &&
                                    rs[j = (m - 1) & h] == null) {
                                    // 将上面创建的 r 放入的 索引位置上
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                cellsBusy = 0;
                            }
                            // 创建cell成功，跳出循环
                            if (created)
                                break;
                            // 说明指定 cells 下标位置的数据不为空，则进行下一次循环
                            continue;           // Slot is now non-empty
                        }
                    }
                    collide = false;
                }
                else if (!wasUncontended)       // CAS already known to fail
                    // cas失败  设置为未冲突表示 进入下一次自旋
                    wasUncontended = true;      // Continue after rehash
                else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))
                    // cas 设置当前索引位上的countCell的值 如果成功则退出
                    break;
                else if (counterCells != as || n >= NCPU)
                    // 如果已经有其他线程建立了新的 counterCells 或者 CounterCells 
                    // 大于 CPU 核心数 (很巧妙，线程的并发数不会超过 cpu 核心数)
                    // 设置当前线程的循环失败不进行扩容
                    collide = false;            // At max size or stale
                else if (!collide)
                    // 进入这个步骤，说明 CounterCell 数组容量不够，线程竞争较大，
                    // 所以先设置一个标识表示为正在扩容
                    collide = true;
                else if (cellsBusy == 0 &&
                         U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                    try {
                        //扩容一倍 2 变成 4
                        // 重新检测
                        if (counterCells == as) {// Expand table unless stale
                            CounterCell[] rs = new CounterCell[n << 1];
                            for (int i = 0; i < n; ++i)
                                rs[i] = as[i];
                            counterCells = rs;
                        }
                    } finally {
                        cellsBusy = 0;
                    }
                    // 扩容成功后 标记修改为false 
                    collide = false;
                    continue;                   // Retry with expanded table
                }
                // 更新随机数的值
                h = ThreadLocalRandom.advanceProbe(h);
            }
            else if (cellsBusy == 0 && counterCells == as &&
                     U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                // CounterCells == null 或 CounterCells长度为0 初始化 CounterCells 数组
                // cellsBusy=0 表示没有在做初始化，通过 cas 更新 cellsbusy 的值
                // 标注当前线程正在做初始化操作
                boolean init = false;
                try {                           // Initialize table
                    if (counterCells == as) {
                        // 初始化长度为2的数组
                        CounterCell[] rs = new CounterCell[2];
                        // 将 x 也就是元素的个数放在指定的数组下标位置
                        rs[h & 1] = new CounterCell(x);
                        counterCells = rs;
                        // 初始化完成
                        init = true;
                    }
                } finally {
                    cellsBusy = 0;
                }
                // 初始化完成 退出循环
                if (init)
                    break;
            }
            else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))
                // 竞争激烈，其它线程占据 cell 数组，直接累加在 base 变量中
                break;                          // Fall back on using base
        }
    }


    /**
     * Replaces all linked nodes in bin at given index unless table is
     * too small, in which case resizes instead.
     */
    private final void treeifyBin(Node<K,V>[] tab, int index) {
        Node<K,V> b; int n, sc;
        if (tab != null) {
            if ((n = tab.length) < MIN_TREEIFY_CAPACITY)
                tryPresize(n << 1);
            else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {
                synchronized (b) {
                    // 双重检测
                    if (tabAt(tab, index) == b) {
                        TreeNode<K,V> hd = null, tl = null;
                        //遍历链表，创建红黑树
                        for (Node<K,V> e = b; e != null; e = e.next) {
                            TreeNode<K,V> p =
                                new TreeNode<K,V>(e.hash, e.key, e.val,
                                                  null, null);
                            if ((p.prev = tl) == null)
                                hd = p;
                            else
                                tl.next = p;
                            tl = p;
                        }
                        // 将红黑树放到对应的位置
                        setTabAt(tab, index, new TreeBin<K,V>(hd));
                    }
                }
            }
        }
    }
    /**
     * Tries to presize table to accommodate the given number of elements.
     *
     * @param size number of elements (doesn't need to be perfectly accurate)
     */
    private final void tryPresize(int size) {
        // size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。
        int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :
            tableSizeFor(size + (size >>> 1) + 1);
        int sc;
        // 0 未初始化
        // > 0 阈值
        while ((sc = sizeCtl) >= 0) {
            Node<K,V>[] tab = table; int n;
            // table未初始化时
            if (tab == null || (n = tab.length) == 0) {
                n = (sc > c) ? sc : c;
                if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                    try {
                        if (table == tab) {
                            @SuppressWarnings("unchecked")
                            Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                            table = nt;
                            sc = n - (n >>> 2);
                        }
                    } finally {
                        sizeCtl = sc;
                    }
                }
            }
            else if (c <= sc || n >= MAXIMUM_CAPACITY)
                // 扩容后的大小小于阈值或大于最大容量
                break;
            else if (tab == table) {
                int rs = resizeStamp(n);
                if (sc < 0) {
                    Node<K,V>[] nt;
                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                        transferIndex <= 0)
                        break;
                    // 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法
                    //  此时 nextTab 不为 null
                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                        transfer(tab, nt);
                }
                else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                             (rs << RESIZE_STAMP_SHIFT) + 2))
                    transfer(tab, null);
            }
        }
    }

```

##### size

- 没有竞争时，向baseCount计数
- 有竞争时，新建counterCells，向其中一个cell累加计数
  - counterCells初始有两个cell
  - 如果计数比较激烈，会创建新的cell来累加计数

```java
    /**
     * Returns the number of key-value mappings in this map. If the map contains more than 
     * Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
     */
    public int size() {
        long n = sumCount();
        return ((n < 0L) ? 0 :
                (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
                (int)n);
    }

    final long sumCount() {
        CounterCell[] as = counterCells; CounterCell a;
        long sum = baseCount;
        if (as != null) {
            //将baseCount和所有cell计数累加
            for (int i = 0; i < as.length; ++i) {
                if ((a = as[i]) != null)
                    sum += a.value;
            }
        }
        return sum;
    }
    /**
     * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.
     */
    private transient volatile int cellsBusy;
    /**
     * Table of counter cells. When non-null, size is a power of 2.
     * 总数值的分值分别存在每个 cell 中
     */
    private transient volatile CounterCell[] counterCells;
```

##### transfer

```java
    /**
     * Moves and/or copies the nodes in each bin to new table. See
     * above for explanation.
     */
    private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {
        int n = tab.length, stride;
        if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)
            stride = MIN_TRANSFER_STRIDE; // subdivide range
        //初始化新table
        if (nextTab == null) {            // initiating
            try {
                @SuppressWarnings("unchecked")
                Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];
                nextTab = nt;
            } catch (Throwable ex) {      // try to cope with OOME
                sizeCtl = Integer.MAX_VALUE;
                return;
            }
            nextTable = nextTab;
            transferIndex = n;
        }
        int nextn = nextTab.length;
        //table中某个位置的的bins已经迁移完成，将fwd填充到table中，代表此位置的数据已经迁移完成
        ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);
        boolean advance = true;
        boolean finishing = false; // to ensure sweep before committing nextTab
        for (int i = 0, bound = 0;;) {
            //f第一个node
            //fh第一个node的hash
            Node<K,V> f; int fh;
            while (advance) {
                int nextIndex, nextBound;
                if (--i >= bound || finishing)
                    advance = false;
                else if ((nextIndex = transferIndex) <= 0) {
                    i = -1;
                    advance = false;
                }
                else if (U.compareAndSwapInt
                         (this, TRANSFERINDEX, nextIndex,
                          nextBound = (nextIndex > stride ?
                                       nextIndex - stride : 0))) {
                    bound = nextBound;
                    i = nextIndex - 1;
                    advance = false;
                }
            }
            if (i < 0 || i >= n || i + n >= nextn) {
                int sc;
                if (finishing) {
                    nextTable = null;
                    table = nextTab;
                    sizeCtl = (n << 1) - (n >>> 1);
                    return;
                }
                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
                    if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)
                        return;
                    finishing = advance = true;
                    i = n; // recheck before commit
                }
            }
            else if ((f = tabAt(tab, i)) == null)
                //下标i处的node迁移完成了，将table中下标i处的null替换为fwd
                advance = casTabAt(tab, i, null, fwd);
            else if ((fh = f.hash) == MOVED)
                //已经处理过了
                advance = true; // already processed
            else {
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        Node<K,V> ln, hn;
                        //fh >=0 代表是普通node，非红黑树
                        if (fh >= 0) {
                            int runBit = fh & n;
                            Node<K,V> lastRun = f;
                            for (Node<K,V> p = f.next; p != null; p = p.next) {
                                int b = p.hash & n;
                                if (b != runBit) {
                                    runBit = b;
                                    lastRun = p;
                                }
                            }
                            if (runBit == 0) {
                                ln = lastRun;
                                hn = null;
                            }
                            else {
                                hn = lastRun;
                                ln = null;
                            }
                            for (Node<K,V> p = f; p != lastRun; p = p.next) {
                                int ph = p.hash; K pk = p.key; V pv = p.val;
                                if ((ph & n) == 0)
                                    ln = new Node<K,V>(ph, pk, pv, ln);
                                else
                                    hn = new Node<K,V>(ph, pk, pv, hn);
                            }
                            setTabAt(nextTab, i, ln);
                            setTabAt(nextTab, i + n, hn);
                            setTabAt(tab, i, fwd);
                            advance = true;
                        }
                        else if (f instanceof TreeBin) {
                            //是红黑树，使用红黑树迁移逻辑
                            TreeBin<K,V> t = (TreeBin<K,V>)f;
                            TreeNode<K,V> lo = null, loTail = null;
                            TreeNode<K,V> hi = null, hiTail = null;
                            int lc = 0, hc = 0;
                            for (Node<K,V> e = t.first; e != null; e = e.next) {
                                int h = e.hash;
                                TreeNode<K,V> p = new TreeNode<K,V>
                                    (h, e.key, e.val, null, null);
                                if ((h & n) == 0) {
                                    if ((p.prev = loTail) == null)
                                        lo = p;
                                    else
                                        loTail.next = p;
                                    loTail = p;
                                    ++lc;
                                }
                                else {
                                    if ((p.prev = hiTail) == null)
                                        hi = p;
                                    else
                                        hiTail.next = p;
                                    hiTail = p;
                                    ++hc;
                                }
                            }
                            ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                                (hc != 0) ? new TreeBin<K,V>(lo) : t;
                            hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                                (lc != 0) ? new TreeBin<K,V>(hi) : t;
                            setTabAt(nextTab, i, ln);
                            setTabAt(nextTab, i + n, hn);
                            setTabAt(tab, i, fwd);
                            advance = true;
                        }
                    }
                }
            }
        }
    }

```

### JDK7 ConcurrentHashMap

维护了一个segment数组，每个segment对应一把锁

- 优点：如果有多个线程访问不同的segment，是不会冲突的
- 缺点：segment数组默认是16，这个容量初始化后就不能改变了，并且不是懒惰初始化

#### 构造器

```java
    /**
     * Creates a new, empty map with the specified initial
     * capacity, load factor and concurrency level.
     *
     * @param initialCapacity the initial capacity. The implementation
     * performs internal sizing to accommodate this many elements.
     * @param loadFactor  the load factor threshold, used to control resizing.
     * Resizing may be performed when the average number of elements per
     * bin exceeds this threshold.
     * @param concurrencyLevel the estimated number of concurrently
     * updating threads. The implementation performs internal sizing
     * to try to accommodate this many threads.
     * @throws IllegalArgumentException if the initial capacity is
     * negative or the load factor or concurrencyLevel are
     * nonpositive.
     */
    @SuppressWarnings("unchecked")
    public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)
            throw new IllegalArgumentException();
        if (concurrencyLevel > MAX_SEGMENTS)
            concurrencyLevel = MAX_SEGMENTS;
        // Find power-of-two sizes best matching arguments
        int sshift = 0;
        // segment数组大小必须是2的n次方
        int ssize = 1;
        while (ssize < concurrencyLevel) {
            ++sshift;
            ssize <<= 1;
        }
        // segmentShift segmentMask 作用是求key在segment数组的下标
        // segmentShift 默认值是 32 - 4 = 28 
        this.segmentShift = 32 - sshift;
        // segmentMask 默认值是 16 - 1 = 15 即 0000 0000 0000 1111
        this.segmentMask = ssize - 1;
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        int c = initialCapacity / ssize;
        if (c * ssize < initialCapacity)
            ++c;
        int cap = MIN_SEGMENT_TABLE_CAPACITY;
        while (cap < c)
            cap <<= 1;
        // create segments and segments[0]
        Segment<K,V> s0 =
            new Segment<K,V>(loadFactor, (int)(cap * loadFactor),
                             (HashEntry<K,V>[])new HashEntry[cap]);
        Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];
        UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
        this.segments = ss;
    }
```

segment结构如下

![image-20220505225528622](\picture\image-20220505225528622.png)

segmentShift segmentMask 作用是求key在segment数组的下标

key的hash无符号右移segmentShift位后，和segmentMask做位与运算得到在segment数组中的位置 

![image-20220505225702153](\picture\image-20220505225702153.png)

#### put流程



```java
    public V put(K key, V value) {
        Segment<K,V> s;
        if (value == null)
            throw new NullPointerException();
        int hash = hash(key);
        // 计算key在segment数组中的下标
        // 相当于key的hash和segments长度取模
        int j = (hash >>> segmentShift) & segmentMask;
        // 获得segment对象，判断是否为null，是则创建segment
        if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck
             (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment
            // 这时不能确定是否segment是否真的为null，因为会存在多个线程同时put的情况，
            // 在ensureSegment方法内使用CAS方式保证segment的线程安全性
            s = ensureSegment(j);
        // 进入segment的put流程
        return s.put(key, hash, value, false);
    }
    /**
     * Returns the segment for the given index, creating it and
     * recording in segment table (via CAS) if not already present.
     *
     * @param k the index
     * @return the segment
     */
    @SuppressWarnings("unchecked")
    private Segment<K,V> ensureSegment(int k) {
        final Segment<K,V>[] ss = this.segments;
        long u = (k << SSHIFT) + SBASE; // raw offset
        Segment<K,V> seg;
        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {
            Segment<K,V> proto = ss[0]; // use segment 0 as prototype
            int cap = proto.table.length;
            float lf = proto.loadFactor;
            int threshold = (int)(cap * lf);
            HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];
            if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))
                == null) { // recheck
                Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);
                while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))
                       == null) {
                    if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))
                        break;
                }
            }
        }
        return seg;
    }
```

Segment继承了可重入锁（ReentrantLock）

```java
        final V put(K key, int hash, V value, boolean onlyIfAbsent) {
            // 尝试加锁
            // 如果失败，进入 scanAndLockForPut，
            // 如果是多核CPU最多tryLock 64次，进入lock流程，
            // 在尝试期间，还可以顺便看该节点在链表中存不存在，如果不存在则创建出来
            HashEntry<K,V> node = tryLock() ? null :
                scanAndLockForPut(key, hash, value);
            V oldValue;
            // 加锁成功
            try {
                HashEntry<K,V>[] tab = table;
                int index = (tab.length - 1) & hash;
                HashEntry<K,V> first = entryAt(tab, index);
                for (HashEntry<K,V> e = first;;) {
                    if (e != null) {
                        K k;
                        // 若key已经存在
                        if ((k = e.key) == key ||
                            (e.hash == hash && key.equals(k))) {
                            oldValue = e.value;
                            if (!onlyIfAbsent) {
                                e.value = value;
                                ++modCount;
                            }
                            break;
                        }
                        e = e.next;
                    }
                    else {
                        // 新增
                        // 若之前scanAndLockForPut若创建了node，将node的next指向链表头
                        if (node != null)
                            node.setNext(first);
                        else
                            //创建新的node
                            node = new HashEntry<K,V>(hash, key, value, first);
                        int c = count + 1;
                        //若超过阈值
                        if (c > threshold && tab.length < MAXIMUM_CAPACITY)
                            rehash(node);
                        else
                            //更新table, t
                            setEntryAt(tab, index, node);
                        ++modCount;
                        count = c;
                        oldValue = null;
                        break;
                    }
                }
            } finally {
                unlock();
            }
            return oldValue;
        }
        /**
         * Scans for a node containing given key while trying to
         * acquire lock, creating and returning one if not found. Upon
         * return, guarantees that lock is held. UNlike in most
         * methods, calls to method equals are not screened: Since
         * traversal speed doesn't matter, we might as well help warm
         * up the associated code and accesses as well.
         *
         * @return a new node if key not found, else null
         */
        private HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) {
            HashEntry<K,V> first = entryForHash(this, hash);
            HashEntry<K,V> e = first;
            HashEntry<K,V> node = null;
            int retries = -1; // negative while locating node
            while (!tryLock()) {
                HashEntry<K,V> f; // to recheck first below
                if (retries < 0) {
                    if (e == null) {
                        if (node == null) // speculatively create node
                            node = new HashEntry<K,V>(hash, key, value, null);
                        retries = 0;
                    }
                    else if (key.equals(e.key))
                        retries = 0;
                    else
                        e = e.next;
                }
                else if (++retries > MAX_SCAN_RETRIES) {
                    lock();
                    break;
                }
                else if ((retries & 1) == 0 &&
                         (f = entryForHash(this, hash)) != first) {
                    e = first = f; // re-traverse if entry changed
                    retries = -1;
                }
            }
            return node;
        }

```

