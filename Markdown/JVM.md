# JVM

跨语言的平台

Java编译器输入的指令流基本上是一种基于栈的指令集架构

java文件-》字节码-》机器码

虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而**虚拟机的执行引擎是由软件自行实现的**，因此可以不受物理条件制约地定制执行引擎的体系结构，**能够执行那些不被硬件直接支持的指令集格式**。

## 类加载子系统（Class Loader Subsystem）

### 加载（loading）

1. 通过一个类的全限定名获取此类的二进制字节流
2. 将字节流所代表的静态数据结构转化为方法区运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区的各种数据的访问入口
   1. 数组类并不是由类加载器负责创建，而是JVM在运行时根据需要直接创建，单数组元素类型仍需要依靠类加载器去创建

类来源：本地文件、网络、zip包、运行时动态生成（动态代理）、有其他文件生成（JSP等）、数据库、加密文件（防止反编译）

### 链接（linking）
1. #### 验证（verify）

    通常与加载环节一起进行，确保class字节码文件的字节流包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全
    主要包括四种验证：文件格式（魔数检查、版本检查，长度检查）、元数据、字节码、符号引用（符号引用的直接引用是否存在，如果一个需要使用的类在系统中无法找到，则会抛出NoClassDefFoundError，如果一个方法无法被找到，则会抛出NoSuchMethodEorror）
2. #### 准备（prepare）

    为静态变量（static修饰的）分配内存并初始化默认值（引用类型赋值null，基本数据类型），不包含常量（final static修饰的），因为final在编译的时候就分配了，准备阶段会显示初始化
3. #### 解析（resolve） 

    将常量池内的符号引用转为为直接引用
    事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行
    **符号引用**就是一组描述所引用的目标，符号引用的字面量形式明确定义在《Java虚拟机规范》的class文件格式中。
    **直接引用**就是直接指向目标的指针、相对偏移量或者间接定位到目标的句柄
    解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的`CONSTANT_Class_info`、`CONSTANT_Feildref_info`、`CONSTANT_Methodref_info`等。


### 初始化（initialization）

1. 执行类构造器方法<clinit>()。
   1. 此方法不需要定义是javac编译器收集类中所有类变量的赋值动作和静态代码块的语句合并而来。
   2. 不会生成<clinit>()。
      1. 无静态变量
      2. 静态变量无显示初始化
      3. 常量使用字面量赋值
2. 构造器方法中指令按语句在源码中出现的顺序执行。
3. <clinit>()不同于类的构造器（<init>()）。
4. 若该类有父类，JVM会保证父类的<clinit>()在子类<clinit>()前执行
5. 虚拟机保证一个类的<clinit>()方法在多线程下被同步加锁。

### 类的主被动使用

被动使用不会不会导致类的初始化（会加载不会有初始化阶段），主动使用会初始化

主动使用七种场景

1. 创建类实例（new、反射、反序列化）
2. 访问或修改类或接口的静态变量
3. 调用类静态方法
4. 反射
5. 初始化一个类的子类（不适用于接口，只有首次使用接口的静态字段才会初始化）
6. Java虚拟机启动时被标记为启动类的类
7. JDK 7 提供带动态语言支持。。。
8. 接口提供了default方法，重写了接口的default方法的类，接口会在该类之前初始化

### 参数

- `-XX:+TraceCLassLoading`，类加载日志。



### 类加载器

Java核心组件，所有的Class都是由ClassLoader进行加载，Class Loader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作，因此，ClassLoader在整个装载阶段，只能影响到类的加载。而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。

#### `Bootstrap CLassLoader`（引导类加载器、启动类加载器）

C/C++实现，嵌套在JVM内部（JVM的一部分）。用于加载核心类库，如JAVA_HOME/jre/lib/rt.jar、resources.jar等。出于安全考虑，它只加载报名为Java、javax、sun等开头的类。

#### `Extension CLassLoader`（扩展类加载器）-`User-Define CLassLoader`（用户自定义类加载器）

java语言编写，派生于ClassLoader，父类加载器为启动类加载器，从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK安装目录的jre/lib/ext子目录下加载类库，**用户自定义的jar放在此目录下也会被扩展类加载器加载**

#### AppClassLoader（应用类加载器）-`User-Define CLassLoader`（用户自定义类加载器）

java语言编写，派生于ClassLoader，父类加载器为扩展类加载器，它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库，一般来说，Java应用的类都是由它来完成加载。

#### 自定义类加载器-`User-Define CLassLoader`（用户自定义类加载器）

默认父加载器是AppClassLoader。 

应用场景：隔离加载类（不同类库类名冲突的情况）、修改类加载的方式、扩展加载源、防止源码泄露

#### 双亲委派机制（parents delegation）

1. 一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；

2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归请求最终将到达顶层的启动类加载器；

3. 如果父类加载器可以完成类加载任务，就返回成功，倘若父类加载器无法完成加载任务，子类加载器才会尝试自己去加载。

   ##### 自定义类加载器的优势

   1. 避免类重复加载
   2. 保护程序安全，防止核心`API`被恶意篡改

   ##### 沙箱安全机制


#### 类的唯一性

- 比较两个是否相等，只有在这两个类是由同一个类加载器的前提下才有意义。否则，即使这两个类源自同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那么这两个类就必定不相等。

#### 命名空间

- 每个类加载器都有自己的命名空间，命名空间由该加载器所有的父加载器所加载的类组成。

#### ClassLoader源码

##### 主要方法

```java
//返回父级类加载器用于委托
public final ClassLoader getParent() 
```

```java
//根据指定的二进制名加载类，该方法中的逻辑就是双亲委派机制的实现
public Class<?> loadClass(String name) throws ClassNotFoundException
```

```java
//根据指定的二进制名查找类。JVM规范鼓励我们重写此方法。
//一般情况下，在自定义类加载器时，会覆盖ClassLoader的findClass()方法，取得要加载类的字节码后转换成流，
//然后调用defineClass()方法生成类的Class对象
protected Class<?> findClass(String name) throws ClassNotFoundException
```

```java
//把字节数组转换为Class类实例
protected final Class<?> defineClass(String name, byte[] b, int off, int len)
```

## 内存与垃圾回收


### 运行时数据区（Runtime Data Area）

#### 方法区（Method Area）

- Non-Heap，独立于堆的内存空间。线程间共享的内存区域。
- 方法区在`JVM`启动的时候被创建，并且它的实际的物理内存空间可以是不连续的。
- 可以固定大小或可扩展。
- 错误：`java.lang.OutOfMemoryError: PermGen space`或`java.lang.OutOfMemoryError: Metaspace `
- 关闭`JVM`就会释放这个区域
- 用于存储已被JVM加载的类型信息、域(Filed)信息、常量、静态变量、即时编译后的代码缓存等。
  - 类型信息
    1. 这个类型的有效名称（包名+类名）
    2. 这个类型的直接父类的完整有效名（对于interface或是Java.lang.Object都没有父类）
    3. 这个类型的修饰符（public、abstract、final的某个子集）
    4. 这个类型的直接接口的一个有序列表
  - 域信息
    1. 域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient的某个子集）
  - 方法信息
    1. 方法名称
    2. 方法的返回类型
    3. 方法参数的数量和类型（按顺序）
    4. 方法的修饰符（public、private、protected、static、synchronized，native、abstract的一个子集）
    5. 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
    6. 异常表（abstract和native方法除外）
       - 每个异常的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。
  - non-final的类变量
    1. 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分。
    2. 类变量被类的所有实例共享，即使没有类实例时你也可以访问它。
  - static final 全局常量
    1. 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。
  - 运行时常量池
    - 常量池表
      1. 数值
      2. 字符串值
      3. 类引用
      4. 字段引用
      5. 方法引用
    - 常量池表是字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池。
    - 在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
    - JVM为每个已经加载的类型（类或接口）都维护一个常量池。池中的数据项就像数组项一样，是通过索引访问的。
    - 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。
      - 运行池常量池相对于Class文件常量池的另一个重要特征是：具备动态性。
    - 运行时常量池类似于传统编程语言中的符号表（symbol table），但它包含的数据却比符号表要更加丰富一些。
    - 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛出OOM异常。
- 方法区垃圾回收
  - 《Java虚拟机规范》对方法区的约束非常宽松，提到过可以不要求虚拟机在方法区中实现垃圾回收。
  - 方法区垃圾收集主要回收两部分的内容：常量池中废弃的常量和不再使用的类型。
  - 判断一个常量是否“废弃”还是相对简单，而要判断一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足以下三个条件
    - 该类的所有实例都已被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
    - 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGI，JSP的重加载，否则通常是很难达成的。
    - 该类对应的`java.lang.Class`对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。
  - JVM允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，`HotSpot`虚拟机提供了`-Xnoclassgc`参数进行控制，还可以使用`-verbose:class`以及`-XX:+TraceClass-Loading`、 `-XX:+TraceClassUnloading`查看类的加载和卸载信息。
  - 在大量使用反射、动态代理、`CGLib`等字节码框架，动态生成JSP以及OSGI这类频繁自定义类加载器的场景中，通常都需要JVM具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。



##### 永久代`JDK1.7`/元空间`JDK1.8`

- 永久代
  - 通过`-XX:PermSize`来设置永久代初始分配空间，默认值20.75`M`
  - `-XX:MaxPermSize`来设置永久代最大可分配空间。32位机器默认是64`M`，64位机器默认是82`M`
  - 异常：`java.lang.OutOfMemoryError: PermGen space`
  - `JDK1.6`及之前静态变量存放在永久代上
  - `JDK1.7`已经逐步“去永久代”，字符串常量池、静态变量移除，保持在堆中。
    - `JDK7`中将字符串常量池放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会触发，而`FG`是老年代、永久代空间不足时才会触发，这就导致`StringTable`回收效率不高。而我们在开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆中能及时回收。
    - 永久代空间小
- 元空间
  - 元空间大小可以使用参数`-XX:MetaspaceSize`和`-XX:MaxMetaspaceSize`指定替换原有的永久代的参数
  - 默认值依赖于平台，Windows下，`-XX:MetaspaceSize`是21`M`，`-XX:MaxMetaspaceSize`的值是-1，即没有限制。
  - 异常：`java.lang.OutOfMemoryError: Metaspace `
  - `-XX:MetaspaceSize`设置初始的元空间大小，对于一个64位的服务器端JVM来说，其默认的`-XX:MetaspaceSize`值为21`M`，这就是初始的**高水位线**，一旦触及这个水位线，Full GC将会被触发并卸载没用的类，然后这个高水位线将会重置，新的高水位线的值取决于GC后释放了多少元空间，如果释放的空间不足，那么在不超过`MaxMetaspaceSize`时，适当提高该值，如果释放过多，则适当降低该值。
  - 如果初始化的高水位线设置过低，**高水位线**调整情况会发生很多次，通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁的GC，建议将`-XX:MetaspaceSize`设置为一个相对较高的值。
  - 类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆。
- 元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。
- 永久代移除的原因
  - 永久代设置空间大小是很难确定的。
  - 对永久代调优是很困难的。

#### 堆（Heap）

##### 概念

- 一个JVM只存在一个堆，堆也是Java内存管理的核心区域。
- Java堆在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大的一块内存空间。
- 堆的大小可以调节
- 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
- 所有的线程共享Java堆，在这里还可以会分为线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。
- 《Java虚拟机规范》中对堆的描述，堆是运行时数据区，所有class实例和array的内存都是从改区域分配的。
- `JDK7`及之前版本堆内存逻辑上分为新生代`Young generation`+老年代`Old generation`+永久代`PermGen`；`JDK8`及之后版本堆内存逻辑上分为新生代+老年代+元空间`MetaSpace`
- 工具 `JVisualVM`插件`Visual GC `


##### 新生代老年代

年轻代：Eden区+ Survivor0 空间+Survivor1空间（也叫from区、to区），S0、S1只会有一个空间存储数据。

- 配置新生代与老年代在堆结构的占比（命令行：`jinfo -flag NewRatio pid `）
  - 默认 `-XX:NewRatio=2`，表示新生代占1，老年代占2，新生代占整个堆的1/3。
  - 修改 `-XX:NewRatio=4`，表示新生代占1，老年代占4，新生代占整个堆的1/5。
- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是`8:1:1`
  - 可以使用`-XX:SurvivorRatio`调整这个空间比例（命令行：`jinfo -flag SurvivorRatio pid`）。
- 几乎所有的Java对象都是在Eden区被new出来的。
- 绝大多数的Java对象的销毁都在新生代进行。
- 可以使用`-Xmn`设置新生代最大内存大小
  - 这个参数一般使用默认值即可。

##### 堆空间设置参数

`-Xms`堆区的起始内存等价于`-XX:InitialHeapSize`，`-Xmx`堆区的最大内存等价于`-XX:MaxHeapSize`

- 一旦堆区的内存大小超过`-Xmx`最大内存所指定的值，将会抛出OutOfMemoryError。
- 通常会将起始内存大小和最大内存大小两个参数配置相等的值，目的是能够在Java垃圾回收机制清理完堆空间后不需要重新分隔计算堆区的大小，从而提升性能。
- 默认情况下，初始内存大小：物理内存 / 64；最大内存大小：物理内存 / 4。

##### 对象分配过程

- Eden区满了会触发YGC/Minor GC，Eden区幸存的对象迁移到幸存者区且幸存对象年龄加一，幸存者区满了不会触发YGC/Minor GC，YGC/Minor GC也会同时对幸存者区进行GC。
- 幸存者区S0、S1复制之后交换，谁空谁是to区。

- S0区到S1区幸存对象的年龄也会加一。
- 若新生代（Eden区、S0、S1）存储不下的对象则直接放到老年代，老年代放不下会触发FGC，FGC后仍然放不下会抛出OOM错误。
- 年轻代中的对象年龄达到阈值后晋升（Promotion）到老年代（默认阈值：15，可通过`-XX:MaxTenuringThreshold=N`调整）。
- 频繁在年轻代收集，很少在老年收集，几乎不在永久代/元空间收集。 

##### GC

JVM在进行GC时，并非每次都对新生代、老年代和方法区一起回收。大部分时候回收的都是新生代。

HotSpot VM的实现S，GC按照回收区域又分为两大种类，一种是部分收集（Partial GC），一种是整堆收集（Full GC）。

###### Partial GC

- Young GC/Minor GC
  - 新生代的垃圾回收
  - 当年轻代空间不足时，就会触发Minor GC，Eden区满会触发，Survivor区满不会触发。Minor GC会清理Eden区和Survivor区的内存。
  - Minor GC会引发STW（Stop The World），暂停其他的用户线程，等待垃圾回收结束，用户线程才恢复运行。

- Major GC
  - 老年代的垃圾回收，目前只有CMS GC会有单独收集老年代的行为
  - 出现Major GC，经常会伴随至少一次的Minor GC（但非绝对的），当老年代空间不足时，会先尝试触发Minor GC。如果空间还不足则触发Major GC
  - Minor GC的速度一般会比Major GC快10倍以上，STW的时间更短。
  - Major GC后，内存还不足，就报OOM。

- Mixed GC
  - 收集整个新生代以及部分老年代的垃圾回收，目前只有G1 GC会有这种行为

###### Full GC

- FGC
  - 收集整个Java堆和方法区的垃圾收集
  - 触发机制：调用`System.gc()`时，系统建议执行FGC，但是不必然执行；老年代空间不足；方法区空间不足；通过Minor GC后进入老年代的平均大小大于老年代的可用内存；由Eden区、S0（From space）向S1（To space）复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。   


##### 堆空间分代思想

分代唯一的理由就是优化GC的性能。

##### 内存分配策略

- 优先分配到Eden区
- 大对象直接分配到老年代
  - 尽量避免程序中出现过多的大对象
- 长期存活的对象分配到老年代
- 动态对象年龄判断
  - 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor区空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到`MaxTenuringThreshold`中要求的年龄。
- 空间分配担保设置
  - `-XX:HandlePromotionFailure`
    - 在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。
      - 如果大于，则此次Minor GC是安全的。
      - 如果小于，则虚拟机会查看`-XX:HandlePromotionFailure`设置值是否允许担保失败。
        - 如果`HandlePromotionFailure=true`，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。
          - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
          - 如果小于，则改为进行一次Full GC。
        - 如果`HandlePromotionFailure=false`，则改为进行一次Full GC。
    - `JDK6 Update24`之后，`HandlePromotionFailure`参数不会再影响虚拟机的空间分配担保策略，`JDK6 Update24`之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。

##### 常用内存参数

- 打印GC详细信息：`-XX:+PrintGCDetails`

![PrintGCDetails详解](C:\Users\MLY\Desktop\MarkDown\20200314215636987.png)

- 查看所有参数的默认初始值：`-XX:+PrintFlagsInitial`
- 查看所有参数的最终值（可能会存在修改，不再是初始值）：`-XX:PrintFlagsFinal`
- 

##### TLAB（Thread Local Allocation Buffer）

- 产生原因
  - 堆区是线程共享区域，任何线程都可以访问到堆区的共享数据
  - 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。
  - 为避免多个线程操作同一个地址，需要使用加锁等机制，进而影响分配速度。
- 定义
  - TLAB是从内存模型而不是垃圾回收的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden区空间内。
  - 多线程同时分配内存时，使用TLAB可以避免一系列的线程安全问题，同时还能提高内存分配的吞吐量，因此我们可以将这种内存分配方式称为*快速分配策略*

- 说明
  - 尽管不是所有对象的实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。
  - 通过`-XX:UseTLAB`设置是否开启TLAB空间
  - 默认情况下，TLAB空间的内存非常小，仅占用整个Eden空间的1%，我们可以通过`-XX:TLABWasteTargetPercent`参数设置TLAB空间所占用的Eden空间的百分比大小。
  - 一旦对象在TLAB空间分配失败时，JVM就会尝试通过使用*加锁机制*确保数据操作的原子性，从而直接在Eden空间中分配内存。

##### 常用调优工具

- JDK命令行
- Eclipse MAT
- JConsole
- Visual VM
- JProfiler
- Java Flight Recorder
- GC Viewer
- GC Easy

##### 堆是分配对象存储的唯一选择吗？

随着`JIT `编译期的发展与`逃逸分析（Escape Analysis）`技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化。所有对象都分配在堆上也渐渐变得不那么*绝对*了。

###### 逃逸分析

- 一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无需进行垃圾回收了。
- 逃逸分析的基本行为就是分析对象动态作用域：
  - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
  - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。
- 参数设置
  - 在`JDK 6u23`之后`HotSpot`中默认就开启了逃逸分析。
  - 如果使用的是较早的版本，开发人员则可以通过：
    - `-XX:+DoEscapeAnalysis`显示开启逃逸分析
    - `-XX:+PrintEscapeAnalysis`查看逃逸分析的筛选结果
- 逃逸分析技术并不成熟，原因是无法保证逃逸分析的性能消耗一定高于它的性能，逃逸分析需要经过一系列复杂的分析，也是一个相当耗时的过程。

##### 基于逃逸分析的代码优化

- 栈上分配
  - 如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。
- 同步省略
  - 如果一个对象只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
  - 可以提高程序的并发性和性能
  - 在动态编译同步块时，`JIT`编译器可以借助逃逸分析来判断同步块所使用的锁对象只能够被一个线程访问而没有发布到其他线程。那么`JIT`编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫锁消除。 
- 分离对象或标量替换
  - 有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。
  - 标量（Scalar），是指一个无法再分解成更小的数据的数据。Java中原始数据类型就是标量。相对的，那些可以分解的数据叫聚合量（Aggregate），Java中的对象就是聚合量。
  - 在`JIT`阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过`JIT`优化，就会把这个对象拆解成若干个成员变量来代替。这个过程就叫标量替换。
  - 标量替换为栈上分配提供了基础
  - 可以大量减少内存的占用（无需创建对象，就不需要分配堆内存了）。
  - 标量替换设置参数使用`-XX:+EliminateAllocations`开启标量替换（默认打开），允许将对象打散分配在栈上。


#### 虚拟机栈（VM Stack）

- 概述

由于跨平台的设计，Java的指令都是根据栈来设计的，不同平台CPU架构不同，所以不能设计为基于寄存器的。

优点是，指令集小，编译器容易实现。缺点是性能下降，实现同样的功能比基于寄存器的需要更多的指令。

线程私有的，主管Java程序的运行，它保存方法的局部变量（八种基本数据类型和对象引用的地址（指向堆空间））、部分结果，并返回方法的调用和返回。

访问速度仅次于程序计数器。

JVM规范允许栈的大小是动态的或固定不变的,可用**-Xss**参数调节，示例：`-Xss1m`、`-Xss1024k`。

异常：`StackOverflowError`

- 栈帧（stack frame）

虚拟机栈的基本单位，线程中每个方法对一个栈帧，方法调用对应入栈（压栈）PUSH，方法返回对应出栈POP。在一个活动的线程中，一个时间点，只有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为**当前栈帧（Current Frame）**，与当前栈帧对应的方法就是**当前方法（Current Method）**,定义这个方法的类就是**当前类（Current Class）**

执行引擎运行的所有字节码指令只针对当前栈帧进行操作。

如果在该方法中调用了其他方法，对应新的栈帧会被创建出来，放在栈顶，成为新的**当前帧**

Java方法有两种返回函数的方式，一种是正常的函数返回，使用return 指令；另一种是抛出异常。不管哪种方式都会导致栈帧被弹出。

* **局部变量表（Local Variables）**

局部变量表也被称为局部变量数组或本地变量表

定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用以及return Address类型。

局部变量表中最基本的存储单元是slot（变量槽）

JVM会为局部变量表中的每一个slot分配一个访问索引，通过这个索引即可访问到局部变量表中指定的局部变量值。

当一个实例方法被调用的时候，它的每一个方法参数和方法体内部的局部变量将会**按照顺序被复制**到局部变量表中的每一个slot上。

如果需要访问局部变量表中一个64 bit的局部变量时，只需使用前一个索引即可（如：long和double类型变量）

如果当前帧是由构造方法或实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。

栈中的局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，之后申明的新的局部变量就很有可能复用过期局部变量的槽位，从而达到节省资源的目的。



在局部变量表里，32位以内的类型只占用一个slot（槽位）（包括return Address），64位类型的（double和long）占用两个slot。

byte、short、char在存储前被转换为int，boolean也被转成int，0表示false，非零表示true，引用类型存储引用地址占一个槽位。

局部变量表建立在线程栈中，是线程私有的数据，不存在并发访问题。

局部变量表的大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables中，在运行期间不会改变局部变量表的大小。

局部变量中的变量也是重要的垃圾回收的根节点（GC Root），只要被局部变量表中的变量直接或间接引用的对象都不会被回收。

* **操作数栈（Operand Stack）**

主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。

操作数栈就是JVM执行引擎的一个工作区，当一个方法开始执行时一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。

操作数栈其所需的最大深度在编译期间就定义好了，保存在方法的Code属性中，为max_stack的值。

栈中32 bit的类型占用一个栈单位深度，64 bit的类型占用两个栈单位深度

操作数栈只能通过push和pop操作来完成一次数据访问。

如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器下一条需要执行的字节码指令

使用`javap -v *.class`反编译class文件

- **动态链接（Dynamic Linking）**

* Class文件的常量池中存在有大量的符号引用,字节码中的方法调用指令就以指向常量池的引用作为参数
  * 部分符号引用在类加载阶段(解析)的时候就转化为直接引用,这种转化为**静态链接**
  * 部分符号引用在运行期间转化为直接引用,这种转化为**动态链接**

* **方法返回值地址（Return Address）**

- 存放调用该方法的PC寄存器的值,一个方法的结束有两种方式 正常执行完成 和出现未处理异常非正常退出。
- 无论哪种方式退出,在方法退出后都返回到该方法被调用的位置，方法正常退出，调用者的PC寄存器的值作为返回地址,即调用该方法的指令的下一条在指令的地址。

* **一些附加信息**
  * 栈帧允许携带一些与JVM实现相关的附加信息,如对程序调优提供支持的信息



- 存储单位
- 代码追踪


- 栈顶缓存技术
- 方法的调用：解析与分派

#### 本地方法栈（Native Method Stack）

一个本地方法就是一个由非Java代码实现的Java方法



#### 程序计数器（Program Counter Register）

是对物理PC寄存器的一种模拟，用来存储指向下一条指令的地址（将要执行的指令），由执行引擎读取。它是一块很小的内存空间。在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程一致。

任何时间一个线程都有一个方法正在执行，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；如果是native方法则是未指定值（undefined）。

它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖程序计数器来完成。

字节码解释器工作时就是通过改变这个计数器的值选取下一条需要执行的字节码指令。

它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

通常是运行速度最快的一个区域。

## 对象实例化

### 创建对象的方式

- new关键字（变形： 单例模式、工厂模式、建造者模式）
- Class的`newInstance()`，只能调用无参构造器，权限必须是public
- Constructor的`newInstance(**)`可以调用无参、带参数的构造器，权限没有要求。
- 使用`clone()`不调用任何构造器，当前类需要实现`Cloneable`接口，实现`clone()`方法
- 使用反序列化
- 第三方库`Objenesis`

### 创建对象的步骤

1. 判断对象对应的类是否加载、链接、初始化

   - 虚拟机遇到一条`new`指令， 首先检查这个指令的参数是否能在`MetaSpace`的常量池中定位到一个类的符号引用。并检查这个符号引用代表的类是否已经被加载、解析和初始化。（判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以`ClassLoader+包名+类命`为Key查找对应的`.class`文件。如果没有找到文件，则抛出`ClassNotFoundException`异常，如果找到则进行类加载，并生成对应的Class类对象。

2. 为对象分配内存

   - 首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节。

   - 如果内存**是规整的**，那么JVM将采用指针碰撞（Bump To Pointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存就是仅仅是把指针向空闲那边挪动一小段与对象大小相等的距离罢了，如果垃圾收集器选择的是`Serial`、`ParNew`这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有`compact`（整理）过程的收集器时，使用指针碰撞。
   - 如果内存是**不规整的**，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。空闲列表法即虚拟机维护的一个列表，记录上哪块内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新表上的内容。

3. 并发安全问题

   - 采用`CAS`失败重试、区域加锁保证更新的原子性。
   - 每个线程预先分配一块`TLAB`通过`-XX:+/-UseTLAB`参数来设定。

4. 初始化分配到的空间

   - 所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用。

5. 设置对象的头

   - 将对象所属的类（类的元数据信息）、对象的`HashCode`和对象的`GC`和锁等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。

6. 执行`init`方法进行初始化

   - 在Java程序的视角来看，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说（由字节码中是否跟随有`invokespecial`指令所决定），new指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。

### 对象的内存布局

- 对象头（Header）
  - 运行时元数据（Mark Word）
    - 哈希值`HashCode`
    - `GC`分代年龄
    - 锁状态标志
    - 线程持有的锁
    - 偏向线程ID
    - 偏向时间戳
  - 类型指针
    - 指向类元数据Instance Class，确定该对象所属的类型
  - 如果是数组，还需要记录数组的长度
- 实例数据（Instance Data）
  - 它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承的和自身定义的字段）
  - 相同宽度的字段总是被分配在一起
  - 父类的字段会出现在子类字段之前
  - 如果`CompactFields`参数为true（默认为true），子类的窄变量可能插入到父类变量的空隙。
- 对象填充（Padding）
- 小结
- ![](C:\Users\MLY\Desktop\Markdown\对象内存布局.jpg)

### 对象访问定位

- 句柄访问

  - 图示

  ![](C:\Users\11690\Desktop\Markdown\对象定位-句柄访问.png)

  - 实现
    - 句柄包含对象实例数据的指针和对象类型信息的指针，间接访问对象实例数据和对象类型数据。
  - 优点
    - 局部变量表中存储句柄信息，对象移动时（垃圾回收时移动对象很普遍）只会改变句柄中实例数据指针，局部变量表中存储的句柄信息不需要被修改。

- 直接指针（Hotspot采用）

  - 图示

  ![](C:\Users\11690\Desktop\Markdown\对象定位-直接指针.png)

  - 实现
    - 局部变量表中的引用对象直接指向堆空间的对象实例数据。
  - 优点
    - 可以直接访问对象实例数据，访问效率更高。

## 执行引擎（Execution Engine）

### 概述

- `JVM`核心组成部分之一
- 执行引擎的任务就是将指令解释/编译为对应平台上的本地机器指令才可以，`JVM`中的执行引擎充当了将高级语言翻译为机器语言的翻译。
- **输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果**。

## Java代码编译和执行的过程



![](C:\Users\11690\Desktop\Markdown\Java代码编译和执行过程.png)

- `-Xint`切换成编译器模式
- `-Xcomp`切换成JIT模式
- `-Xmixed`混合模式

### 解释器

- 当`JVM`启动时会根据预定义的规范**对字节码采用逐行解释执行的方式**，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。

### 即时编译器

- `JIT`（Just In Time Complier）编译器，就是虚拟机将源代码（字节码）直接编译成本地机器平台相关的机器语言。

- `Hotspot`虚拟机内嵌了两个`JIT`，分别为Server Compile和Client Compile，大多数情况我们简称为`C1`编译器和`C2`编译器，开发人员可以通过以下命令显式指定`JVM`在运行时到底使用哪一种编译器。

- `-client`指定虚拟机在Client模式下运行，并使用`C1`编译器

  - `C1`编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。

- `-server`指定虚拟机在Server模式下运行，并使用`C2`编译器（64位机器只支持server模式）

  - `C2`进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。

- 热点代码及探测方式

  - 是否需要启动`JIT`编译器将字节码直接编译为机器码则需要根据代码被调用**执行频率**而定，那些需要被编译成对应平台的机器指令的字节码称之为**热点代码**，`JIT`编译器在运行时会针对那些频繁被调用的代码做出深度优化，将其直接编译成对应平台的机器指令，以提升Java程序的性能。

  - 一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为**热点代码**，因此都可以通过`JIT`编译器编译成本地机器指令。由于这种编译方式发生在方法的指令过程中，因此也被称之为站上替换`OSR`（On Stack Replacement）编译。

  - 目前`Hotspot`所采用的，热点探测方式是基于计数器的热点探测

    - `Hotspot`虚拟机会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）.

      - 方法调用计数器用于统计方法的调用次数。
      - 回边计数器用于统计循环体执行的循环次数。

    - 回边计数器

      ![](C:\Users\11690\Desktop\Markdown\回边计数器.png)

    - 方法调用计数器

      - 它的默认阈值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发`JIT`
      - 这个阈值可以通过参数`-XX:CompileThreshold`来设置。
      - 图示（是否超过阈值会判断方法调用计数器和回边计数器的和是否超过阈值）

      ![](C:\Users\11690\Desktop\Markdown\方法调用计数器.jpg)

      - 热度衰减
        - 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数，当超过**时间限度**，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的程序计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay）,而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）。
        - 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数`-XX:-UseCounterDecay`来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话只要系统运行时间够长，绝大多数方法都会被编译成本地代码。
        - 可以使用`-XX:CounterHalfLifeTime`参数设置半衰周期的时间，单位是秒。

![](C:\Users\11690\Desktop\Markdown\执行引擎.jpg)

### AOT编译器

- `JDK9`引入`AOT`编译器,静态提前编译器（Ahead Of Time Compiler）
- `JDK9`引入实验性`AOT`编译工具`jaotc`。它借助了`Graal`编译器，将所输入的Java类文件转换成机器码，并存放至生成的动态共享库之中。
- `AOT`编译是与即时编译相对立的一个概念，`AOT`指的是在程序运行之前便将字节码转换成机器码的过程。
  - 缺点
    - 破坏了Java“一次编译，打出运行”的特征。
    - 降低了Java连接过程的动态性，加载的代码在编译期就必须全部已知



## StringTable

### String的基本特性

- 不可变类，不可被继承。
- Java中字符串以Unicode表示
- 实现了Serializable、Comparable接口
- `JDK8`及之前版本内部定义了final char[] value用于存储字符串数据。`JDK9`改成了byte[]。
  - 现状是很多情况下一个byte可以存下一个字符（汉字不行），用byte可以节省一半空间。
- 字符串常量池中是不会存储相同内容的字符串的。
  - String的String Pool是一个固定大小的`Hashtable`，默认长度是1009，如果放入String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了之后会造成的影响就是当调用`String.intern()`时性能会大幅下降。
  - 使用`-XX:StringTableSize`可设置`StringTable`的长度。
  - 在`JDK6`中`StringTable`的长度是固定的，就是1009，所以如果常量池中的，字符串过多就会导致效率下降很快。`StringTableSize`设置没有要求。
  - 在`JDK8`中`StringTable`的长度默认值是60013，1009是可以设置的最小值。
- String的内存分配
  - String常量池的使用方法
    -  直接使用双引号声明出来的String对象会直接存储在常量池中`String s= "string"`
    -  使用String提供的`intern()`方法。
  - `JDK6`及之前，字符串常量池在永久代
  - `JDK7`，`JDK8`字符串常量池调整到堆内存中


### String的基本操作

#### 字符串拼接操作

- 常量与常量拼接结果在常量池，原理是编译器优化
- 常量池中不会存在相同内容的常量
- 只要其中一个是变量，结果就在堆中。变量拼接的原理是`StringBuilder`
- 如果拼接的结果调用`intern()`方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。


```java
    @Test
    void test3() {
        String a = "a";
        String b = "b";
        String ab = "ab";
        String s = a + b;
        System.out.println(ab == s);//false
    }
    @Test
    void test4(){
        final String a = "a";
        final String b = "b";
        String ab = "ab";
        String s = a + b;
        System.out.println(ab == s);//true
    }
```

#### intern()的使用

- `intern()`方法会从常量池中查询当前字符串是否存在，~~若不存在就会将当前字符串放入常量池，并返回常量池中引用，否则直接返回常量池中引用~~。

  - 不存在
    - `JDK6`会在永久代的字符串常量池中创建新的字符串对象，方法返回永久代中的地址。
    - `JDK7`及之后版本，会把堆空间对象的引用复制一份放入字符串常量池，没有在字符串常量池中创建新对象，方法返回字符串常量池中复制的引用地址。
  - 存在
    - 直接返回字符串常量池中的地址

  ```java
      public static void main(String[] args) {
          //因String构造方法入参使用"1"（使用字面量会直接在字符串常量池中生成）会导致在创建s对象之前
          // 在字符串常量池已经生成"1"的对象
          String s = new String("1");
          s.intern();// 字符串常量池中已经存在
          String s2 = "1";
          System.out.println(s == s2);//jdk6 false;jdk7/8 false
  
          String s3 = new String("1") + new String("1");//不会在字符串常量池中生成"11"对象
          s3.intern();// 常量池中是s3的引用的复制品
          String s4 = "11";
          System.out.println(s4 == s3);//jdk6 false;jdk7/8 true
      }
  ```



### StringTable的垃圾回收

```java
/**
 * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics 字符串常量池统计信息 -XX:+PrintGCDetails GC详细信息
 *
 * @author : huang.yaohua
 * @date : 2022/2/26 16:30
 */
public class StringTableGCTest {
    public static void main(String[] args) {
        for (int i = 0; i < 100000; i++) {
            String.valueOf(i).intern();
        }
    }
}
```



### G1垃圾回收器字符串去重



## 垃圾回收

### 概述

- 什么是垃圾
  - An object is considered garbage when it can no longer be reached from any pointer in the program .

- Java垃圾回收机制，自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄露和溢出的风险。
- 自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发。
- [垃圾回收介绍](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html)

### 算法

#### 垃圾标记阶段：对象是否存活

- 在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中那些是存活对象，哪些是已经死亡的对象，只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此我们将这个过程称为垃圾标记阶段。
- 当一个对象不被任何指针引用的时候就可以标记为死亡对象。
- 判断对象存活一般有两种方式：引用计数算法和可达性分析算法。
  - 引用计数算法
    - 对每个对象保存一个整型的引用计数器，用于记录对象被引用的情况。
    - 对于任意一个对象A，只要被引用了一次则A的引用计数器就加1，当引用失效时引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能在被使用，可以进行回收。
    - 优点：实现简单，垃圾对象便于辨别；判定效率高，对象没有延迟性。
    - 缺点：
      - 需要单独的字段存储计数器，这样的作法增加了存储空间的开销
      - 每次赋值都需要更新计数器，伴随着加减法操作，增加了时间开销
      - 严重的一个问题，无法处理循环引用的情况，这是一条致命缺陷，导致Java的垃圾回收器中，没有使用这类算法。
  - 可达性分析算法（追踪性垃圾收集Tracing Garbage Collection）
    - GC Roots，根集合就是一组必须活跃的引用
      - GC Root
        - 虚拟机栈中引用的对象（局部变量、参数等）
        - 本地方法栈`JNI`（通常说的是本地方法）引用的对象
        - 方法区静态属性引用的对象（静态成员）
        - 方法区中常量引用的对象（字符串常量池里的引用）
        - 所有同步锁synchronized持有的对象
        - Java虚拟机内部的引用（基本数据类型对应的Class对象、一些常驻的异常对象，如：`NullPointerException`、`OutOfMemoryError`），系统类加载器。
        - 反映Java虚拟机内部的`JMXBean`、`JVMTI`中注册的回调、本地代码缓存等
        - 除了这些固定的GC Root外，根据用户所选的垃圾回收器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整的GC Roots，比如分代收集和局部回收（Partial GC）
    - 可达性分析算法是以根对象集合（GC Roots）为起点，按照从上至下的方式搜索被根对象集合所连接目标对象是否可达
    - 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链（Reference Chain）
    - 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。
    - 只有能够被根集合直接或间接连接的对象才是存活对象。
    - **使用此种算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性地快照中进行，这点不满足的话分析结果的准确性就无法保证**。
      - 这也是导致GC进行时必须进行`Stop the word`的一个重要原因。
      - 即使是号称几乎不会发生停顿的CMS收集器，枚举根节点时也必须要停顿。

#### 垃圾清除阶段

- 标记-清除（Mark-Sweep）算法

  - 此算法是一种非常基础和常见的垃圾收集算法，该算法被`J.McCarthy`等人在1960年提出并应用于Lisp语言。
  - 执行过程
    - 当堆空间中可用内存空间（available memory）被耗尽时，就会停止整个程序（stop the world）,然后进行两项工作，第一项则是标记，第二项则是清除。
      - 标记：Garbage Collector从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的Header中记录为可达对象。
      - 清除：Garbage Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。
        - 这里的清除不是真的置空，而是把需要清除的对象地址保存在空闲地址列表里，下次有新的对象需要加载时，判断垃圾的位置空间是否足够，如果够就存放新的对象。
  - 优缺点
    - 缺点
      - 执行效率不高
      - 在进行GC的时候，需要停止整个应用程序，影响用户体验
      - 这种算法清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表
    - 优点
      - 简单、基础。

- 复制算法（Copying）-（年轻代垃圾回收算法）

  - 为了解决标记-清除算法在垃圾回收效率方面的缺陷，`M.L.Minsky`于1963年发表了著名的论文。
    - 核心思想就是将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。
  - 优缺点
    - 优点
      - 没有标记和清除过程，实现简单，运行高效。
      - 解决了标记-清除算法出现的内存碎片化问题
    - 缺点
      - 需要的内存空间是原来的一倍
      - 对于G1这种分拆为大量region和GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小
      - 如果系统中的垃圾对象很少，复制算法需要复制的存活对象数量就会很多，复制成本高。此种算法适用于年轻代垃圾回收（**年轻代存活对象少**）（**老年代存活对象多使用此种算法将增加复制成本**）。

- 标记-整理算法（Mark-Compact）

  - 为了解决标记-清除算法的缺点（效率低、空间碎片等）而出现。1970年前后`G.L.Steele`、`C.J.Chene`和`D.S.Wise`等研究者发布标记-整理算法。
  - 执行过程
    - 标记：同标记-清除算法。
    - 整理：将所有存活的对象压缩到内存的一端，按顺序排放。
    - 之后清除边界外所有的空间。
  - 标记-整理算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此也可以将其称之为标记-清除-压缩（Mark-Sweep-Compact）算法，标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的，是否移动回收后存活的对象是一项优缺点并存的风险决策（使用标记-整理算法，JVM只需要维护一个内存的起始地址即可，比维护一个空闲列表明显少了许多开销）
  - 优缺点
    - 优点
      - 消除了标记-清除算法中内存区域分散的缺点，我们给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
      - 消除了复制算法中内存减半的高额代价
    - 缺点
      - 效率低于标记-清除算法。
      - 移动对象的同时，如果对象被引用，还需要调整引用的地址
      - 移动过程中，需要暂停用户应用程序，即`STW`

- 分代收集算法

  ![](C:\Users\11690\Desktop\Markdown\分代收集算法.png)

  ![](C:\Users\11690\Desktop\Markdown\分代收集算法-2.png)

- 总结

![](C:\Users\11690\Desktop\Markdown\垃圾回收算法比较.jpg)

#### 增量收集算法（Incremental Collecting）

- 上述算法，在垃圾回收过程中，应用程序将处于Stop The World的状态，在此种状态下所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成，如果垃圾回收时间较长，应用程序会被挂起很久，将严重影响用户体验或系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究导致了**增量收集**算法的诞生
- 基本思想
  - 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用线程交替执行，每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用线程，依次反复，直到垃圾收集完成。
  - 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。
- 缺点
  - 使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统停顿的时间，但是线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升。造成系统吞吐量的下降。

#### 分区算法

一般来说，在相同情况下，堆空间越大，一次GC所需要的时间就月长，有关GC产生的停顿也越长，为了更好的控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理回收若干个区间，而不是整个堆空间，从而减少一次GC所产生的停顿。

分区算法将整个堆空间划分成连续的不同小区间（region）

每一个小区间都独立使用，独立回收，这种算法的好处是可以控制一次回收多个小区间。



### 对象的finalization机制

- Java提供对象终止机制允许开发人员自定义对象销毁前的处理逻辑
- 垃圾回收对象前，会调用此对象的`finalize()`方法
- `finalize()`允许被重写
- 永远不要主动调用某个对象的`finalize()`方法，应该交给垃圾回收器调用，理由如下：
  - 在调用`finalize()`时可能导致对象复活
  - `finalize()`方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则`finalize()`方法将没有机会执行。
  - 一个糟糕的`finalize()`会严重影响GC的性能
- 从功能上说，`finalize()`方法与C++中的析构函数比较相似
- 由于`finalize()`方法的存在，虚拟机中的对象一般处于三种可能的状态。
  - 可触及的：从GC Root开始，可以达到这个对象。
  - 可复活的：对象的所有引用都被释放，但是对象有可能在`finalize()`中复活
  - 不可触及的：对象的`finalize()`被调用，没有复活，那么就会进入不可触及状态，不可触及对象不可复活，因为`finalize()`方法只会被调用一次

- 判断一个对象是否可回收，至少要经历两次标记过程：
  1. 如果对象A到GC　Roots没有引用链则进行一次标记
  2. 进行筛选,判断此对象是否有必要执行`finalize()`方法
     1. 如果对象A没有`finalize()`方法或已经被虚拟机调用过，则虚拟机视为“没有必要执行”，对象A被判定为不可触及的。
     2. 如果对象A重写了`finalize()`且还未被执行过，那么对象A会被插入到`F-Queue`队列中，由虚拟机自动创建的、低优先级的`Finalizer`线程触发其`finalize()`执行
     3. `finalize()`是对象逃脱死亡最后的机会，稍后GC会对`F-Queue`队列中的对象进行二次标记。如果对象A在`finalize()`方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，对象A会从“即将回收”集合中移出。之后，对象出现再次出现没有引用的情况，在这种情况下，对象A的`finalize()`不会被再次调用，对象直接变成不可触及的状态，也就是说一个对象的`finalize()`只会被调用一次。

### 垃圾回收器

#### 概述

- 垃圾回收器在规范中没有过多的规定，可以由不同的厂商，不同版本的JVM来实现

#### 分类

- 按线程数分，可以分为**串行垃圾回收器（Serial）**和**并行垃圾回收器（Parallel）**。

  - 串行垃圾回收器在单核CPU或者应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行收集器和并发收集器
  - 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行收集器。

- 按工作模式分，可以分为**并发式垃圾回收器**和**独占式垃圾回收器**

  - 并发式垃圾回收器与应用线程交替工作，以尽量减少应用程序的停顿时间
  - 独占式垃圾回收器`STW`一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。

  ![](C:\Users\11690\Desktop\Markdown\并发并行垃圾回收器.jpg)

- 按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。

  - 压缩式垃圾回收会在回收完后，对存活对象进行压缩整理，消除回收后的碎片，非压缩垃圾回收器则不会。

- 按工作内存区间分，可分为年轻代垃圾回收器和老年代垃圾回收器

#### 评估GC性能指标

- **吞吐量**（Throughput）：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）
- 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例
- **暂停时间**（Pause time）：执行垃圾收集时，程序的工作线程被暂停的时间
- 收集频率：相对于应用程序的执行，收集操作发生的频率
- **内存占用**：Java堆区所占用的内存大小
- 快速：一个对象从诞生到被回收所经历的时间。

![](C:\Users\MLY\Desktop\Markdown\垃圾回收器吞吐量与暂停时间关系.png)

#### 垃圾回收器发展史

![](C:\Users\MLY\Desktop\Markdown\垃圾回收器发展史.png)

#### 经典垃圾回收器

- 串行回收器：Serial、Serial Old
- 并行回收器：ParNew、Parallel Scavenge、Parallel Old
- 并发回收器：CMS、G1

![](C:\Users\MLY\Desktop\Markdown\垃圾回收器与垃圾分代关系图.png)

![](C:\Users\11690\Desktop\Markdown\垃圾回收器的组合关系.png)

红色虚线：在`JDK8`中废弃，在`JDK9`中移除

其中Serial Old作为CMS出现“Concurrent Mode Failure”失败的后备方案

绿色虚线：在`JDK14`中弃用Parallel Scavenge与Serial Old的组合，移除CMS回收器

#### 查看默认的垃圾回收器

- `-XX:+PrintCommandLineFlags`查看命令行相关参数（包含使用的垃圾收集器）
- 使用命令行`jinfo -flag 相关垃圾回收器参数 pid`

#### Serial回收器：串行回收

- `JDK1.3`之前回收新生代唯一的选择
- Serial收集器作为Hotspot中Client模式下的默认新生代垃圾收集器
- Serial收集器采用复制算法、串行回收和`STW`机制执行内存回收
- 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样也采用了串行回收和`STW`机制，只不过内存回收算法使用的是标记-压缩算法。
  - Serial Old是运行在Client模式下老年代默认的垃圾收集器
  - Serial Old在Server模式下主要有两个用途，一是与新生代的Parallel Scavenge配合使用，二是作为老年代CMS收集器的后备垃圾收集方案。
- 优势
  - 简单而高效，对于限定单个CPU的环境来说，Serial回收器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择
  - 在桌面应用场景，可用内存一般不大（几十上百MB），可以在较短时间内完成垃圾收集
  - 在Hotspot虚拟机中，使用`-XX:+UseSerialGC`参数可以指定年轻代和老年代都是用串行收集器
    - 等价于新生代用Serial GC且老年代用Serial Old GC
  - 

![](C:\Users\11690\Desktop\Markdown\Serial回收器.jpg)

#### ParNew回收器：并行回收

- ParNew回收器是Serial收集器的多线程版本
  - Par是Parallel的缩写，New：只能处理新生代
- ParNew收集器除了采用并行回收的方式执行内存回收外与Serial回收器几乎没有区别
- ParNew是很多JVM在Server模式下新生代默认的垃圾收集器。
- ParNew回收器运行在多核CPU环境下，可以充分发挥CPU多核心的硬件优势，可以更快速的完成垃圾收集，提升程序吞吐量 。
- 使用`-XX:+UserParNewGC`开启，使用`-XX:ParallelGCThreads`限制线程数量，默认开启和CPU核心数相同的线程数。

![](C:\Users\11690\Desktop\Markdown\ParNew回收器.jpg)

#### Parallel Scavenge：吞吐量优先

- Parallel Scavenge收集器同样采用了复制算法、并行回收和`STW`机制

- 与ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。
- 自适应调节策略也是Parallel Scavenge与ParNew的一个重要区别。
- 高吞吐量可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务，因此，常见在服务器环境中使用。例如，批量处理、订单处理、工资支付、科学计算的应用程序。
- Parallel收集器在`JDK1.6`时提供了用于执行老年代垃圾收集的`Parallel Old`收集器，用来代替`Serial Old`收集器
- Parallel Old收集器采用了**标记-压缩算法**，同样基于并行回收和`STW`机制。
- 在吞吐量优先场景中，Parallel收集器与Parallel Old的组合，在Server模式下内存回收的性能很不错
- 是`JDK8`的默认垃圾收集器
- `-XX:+UseParallelGC`指定使用此垃圾收集器、`-XX:UseParallelOldGC`指定老年代使用此垃圾收集器
  - 上面两个参数默认开启一个，另一个也会被开启（相互激活）
- 使用`-XX:ParallelGCThreads`限制年轻代并行垃圾收集器线程数量，
  - CPU小于等于8时，默认开启和CPU核心数相同的线程数。CPU大于8，默认值为3 + 5 * cpu_cores / 8
- `-XX:MaxGCPauseMillis`设置垃圾收集器的最大停顿时间（STW）。单位毫秒。**慎重使用**
- `-XX:GCTimeRatio`垃圾收集时间占总时间比例（= 1 /  (N + 1)）。用于衡量吞吐量。
  - 取值范围(0,100)。默认值99，也就是垃圾收集时间不超过1%.
  - 与上一个参数有一定矛盾性，暂停时间越长，Ratio参数就容易超过设定的比例。
- `-XX:+UseAdaptiveSizePolicy`设置Parallel Scavenge收集器，具有自适应调节策略。
  - 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄参数会被自动调整，已达到在堆大小、吞吐量和时间之间的平衡点。
  - 再手动调优比较困难的场合，可以使用这种方式，让虚拟机自己完成调优工作。

#### CMS回收器：低延迟

- `JDK1.5`Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent Mark Sweep）收集器，这款垃圾收集器，是Hotspot虚拟机中第一款真正意义上的并发收集器，实现了垃圾收集线程与用户线程同时工作。
- `JDK9`中被废弃
- CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延时）就越适合与用户交互的程序，良好的响应速度能提升用户体验。
- CMS的垃圾收集算法采用**标记-清除**算法，也会`STW`。
- 初始标记（STW）-并发标记（Concurrent）-重新标记（STW）-并发清理（Concurrent）
  - 初始标记（Initial-Mark）：这个阶段中，程序中所有的工作线程都会因`STW`机制而出现短暂的暂停，这个阶段的主要任务仅仅是标记出GC Roots直接关联的对象，一旦标记完成就会之后就会恢复之前被暂停的所有应用线程，由于直接关联的对象数量相对较少，所以此阶段执行时间相对而言非常快
  - 并发标记（Concurrent-Mark）：从GC Roots直接关联的对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
  - 重新标记（Remark）：由于在并发标记阶段中，程序的工作线程回和垃圾收集线程同时运行或交替运行，因此为了**修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录**，这个阶段的停顿时间通常会比初始标记阶段耗时更长，但也远比并发标记阶段耗时短。
  - 并发清除（Concurrent-Sweep）：此阶段清理删掉标记阶段判断的已经死亡的对象，释放内存空间，由于不需要移动存活对象，所以这个阶段也可以与用户线程并发执行。
- 由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，应确保用户线程有足够内存可用，因此CMS不能像其它垃圾收集器一样等到老年代几乎被填满了在进行收集，而是当堆内存使用率达到某一阈值时，便开始回收，以确保CMS回收器工作过程中依然有足够的内存支持应用程序运行，如果CMS运行期间预留的内存无法满足程序需求，就会出现`Concurrent Mode Failure`失败，这时将启动后备方案，临时启用Serial Old收集器来重新进行老年代的垃圾收集。
- 优缺点
  - 优点
    - 并发收集
    - 低延迟
  - 缺点
    - 采用了标记-清除算法，会产生内存碎片
    - CMS回收器对CPU资源非常敏感，在并发阶段，会占用CPU资源导致总吞吐量降低
    - CMS收集器无法处理浮动垃圾（垃圾收集线程与用户线程并发执行期间产生的垃圾）。
- `-XX:+UseConcMarkSweepGC`指定老年代垃圾回收器
  - 开启该参数后会自动将`-XX:UseParNewGC`打开。即：ParNew（年轻代）+CMS（老年代）+Serial Old（老年代）的组合
- `-XX:CMSInitiatingOccupancyFraction`设置堆内存使用率的阈值，一旦达到该阈值，便开始回收。
  - `JDK5`及以前版本的默认值为68，即当老年代的空间使用率达到68%，会执行一次CMS回收，`JDK6`及以上版本默认值为92%
  - 如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则可以降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可有效降低Full GC地执行次数。
- `-XX:+UseCMSCompactAtFullCollection`用于指定在执行完Full GC后堆内存空间进行压缩整理以避免内存碎片的产生，不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间更长了。
- `-XX:CMSFullGCsBeforeCompaction`设置在执行多少次Full GC后内存空间进行压缩整理。
- `-XX:ParallelCMSThreads`设置CMS线程数量。
  - CMS默认启动的线程是（(ParallelGCThreads + 3) / 4），ParallelGCThreads 是年轻代并行收集器的线程数，当CPU资源比较紧张时，收到CMS收集线程影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。

![](C:\Users\11690\Desktop\Markdown\CMS回收器.jpg)

#### G1（Garbage First）回收器：区域分代化

- G1垃圾收集器官方设定的目标是**在延迟可控的前提下获得尽可能高的吞吐量**，所以才担当起“全功能收集器”的重任与期望。

- G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region），物理上不连续的，使用不同的Region来表示Eden、Survivor区和老年代。

- Another novelty of G1 is that during the concurrent phase it estimates the amount of live data that each region contains. This is used in building the collection set: the regions that contain the most garbage are collected first. Hence the name: *garbage-first* collection.

- [G1参考资料](https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1)

- G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的回收时间，优先回收价值最大的region。

- 由于这种方式的侧重点在于回收垃圾最大量的区间（region），所以我们给G1一个名字：垃圾优先（Garbage First）

- G1是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高的概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征

- `JDK1.7`正式启用，移除了Experimental的标签，是`JDK9`以后默认的垃圾回收器，取代了CMS回收器以及Parallel Scanvenge+ Parallel Old的组合，被Oracle官方称为“全功能的垃圾收集器”。

- G1回收器的特点

  - 并行并发
    - 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力，此时用户线程暂停
    - 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说不会在整个回收阶段发生完全阻塞应用程序的情况。

  - 分代收集
    - 从分代上看，G1依然属于分代型垃圾收集器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区，但从堆的结构上看，它不要求整个Eden区、年轻代或老年代都是连续的，也不再坚持固定大小和固定数量。
    - 将堆空间分为若干个相同大小的区域（Region）
      - 这些区域中包含了逻辑上的年轻代（Eden区和Survivor区）和老年代。
      - 增加了新的内存区域Humongous内存区域，主要用于存储对象（超过0.5个region就被认定为大对象）。
        - 对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响，为了解决这个问题，G1划分了一个Humongous区，它专门用来存放大对象，如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储，为了能找到连续的H区，有事不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。

    <img src="C:\Users\11690\Desktop\Markdown\分区Region.png" style="zoom:50%;" />

    <img src="C:\Users\11690\Desktop\Markdown\分区Region2.png" style="zoom:50%;" />

    - 和其它垃圾收集器不同，它同时兼顾年轻代和老年代。

  - 空间整合
    - G1将内存划分为一个一个的Region，内存的回收是以Region作为基本单位的，region之间是复制算法，但整体可以看作是标记-压缩算法，这种特性有利于程序长时间运行。在堆空间非常大的情况下，G1的优势更明显。

  - 可预测的停顿时间模型（soft real-time）
    - 能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集的时间不超过M毫秒。
    - 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到一个较好的控制。
    - G1跟踪个Region里面垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表。每次根据允许的收集时间，优先回收价值最大的Region，保证了G1收集器在有限的时间内获取尽可能高的收集效率
    - 相比CMS，G1未必能做到CMS在最好情况下的延时停顿，但最差情况要好得多。

- 缺点

  - 相较于CMS，G1回收器还不具备全方位、压倒性优势。
  - 从经验上来说，在小内存应用上CMS的表现大概率会优于G1。而G1在大内存应用上发挥其优势，平衡点在6-8G之间。

- 参数

  - `-XX:+UseG1GC`指定使用G1收集器
  - `-XX:G1HeapRegionSize`设置每个region的大小，值是2的幂，范围是1MB到32MB，目标是根据最小的Java堆划分出约2048个区域，默认是堆内存的1/2000。
  - `-XX:MaxGCPauseMillis`设置期望达到的最大GC停顿时间指标（不能保证），默认值是200ms
  - `-XX:ParallelGCThreads`设置STW时GC线程的值，最多设置为8
  - `-XX:ConcGCThreads`设置并发标记的线程数，将n设置为并行垃圾回收线程数（ParallelGCThreads）的四分之一左右。
  - `-XX:InitiatingHeapOccpancyPercent`设置触发并发GC周期的Java堆占用率阈值，超过此值就触发GC。默认值是45。

- 适用场景

  - 面向服务端应用，针对具有大内存，多核心处理器的机器（在普通大小堆的表现并不好）。
  - 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案。
  - 以下情况使用G1比CMS好
    - 超过50%的堆被活动数据占用
    - GC停顿时间过长(大于0.65到1秒)
    - 对象分配频率或年代提升频率变化很大
  - 在Hotspot垃圾收集器里，除了G1外，其它的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 回收器可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用线程帮助加速垃圾回收过程。

- Remembered Set

  - 为了解决一个对象被跨代引用的问题（年轻代对象被老年代对象引用）,避免年轻代垃圾回收时扫描整个老年代，减少GC时间。
  - JVM使用Remembered Set来解决此问题（无论G1回收器还是其它垃圾回收器都是用这种方式）
  - 每个Region都有一个对应的Remembered Set
  - 每次Reference类型数据写操作时，都会产生一个Write Barrier暂停中断操作，然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其它回收器检查老年代是否引用了新生代对象），如果不同，通过`CardTable`把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中。当进行GC时，在GC Roots的枚举范围加入Remembered Set，就可以保证不进行全局扫描，也不会有遗漏。
    - `CardTable`是Remembered Set的一种实现

- G1回收过程主要包括以下三个环节

  - Young GC
    - JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden区空间耗尽时，G1会启动YGC
    - YGC只回收Eden区和Survivor区
    - YGC时，首先STW，创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含Eden区和Survivor区所有的内存分段。
  - Concurrent marking
  - Mixed GC
  - 如果需要，单线程、独占式、高强度的Full GC还是继续存在的，它针对GC的评估失败提供了一种失败保护机制，即强力回收

  <img src="C:\Users\11690\Desktop\Markdown\G1回收器的回收过程.png" style="zoom:50%;" />

  <img src="C:\Users\11690\Desktop\Markdown\G1回收器的回收过程2.png" style="zoom:50%;" />

- G1回收器优化建议
  - 避免使用`-Xmn`或`-XX:NewRatio`等相关选项显示设置年轻代的大小（固定年轻代大小会覆盖暂停时间目标）
  - 暂停时间目标不要太苛刻
    - G1回收器的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间。

#### 总结

![](C:\Users\MLY\Desktop\Markdown\垃圾回收器总结.png)

#### GC日志分析

- `-XX:+PrintGC`输出GC日志，类似：-verbose:gc
- `-XX:+PrintGCDetails`输出GC日志详细信息
- `-XX:+PrintGCTimeStamps`输出GC的时间戳（以基准时间的形式）
- `-XX:+PrintGCDateStamps`输出GC的时间戳（日期格式：）
- `-XX:+PrintHeapAtGC`在GC的前后打出堆的信息
- `-Xloggc:../logs/gc.log`日志文件输出路径
- 日志分析工具：GCViewer、GCEasy、GCHisto、GCLogViewer、garbageCat、Hpjmeter。

![](C:\Users\MLY\Desktop\Markdown\GC日志分析.png)

### 其它

#### System.gc()

- 默认情况下，通过`System.gc()`或`Runtime.getRuntime().gc()`的调用，会显示触发`Full GC`,同时对新生代和老年代进行回收
- 调用此方法无法保证对垃圾回收器的调用
- JVM实现者可以通过`System.gc()`调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无需手动触发，否则就太过于麻烦了，在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用`System.gc()`。

#### 内存溢出和内存泄漏

- 内存溢出

会导致OutOfMemoryError，可用内存空间不足，经过垃圾回收后可用内存空间仍然不足。

- 内存泄漏（Memory Leak）
  - 只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏
  - 通常是一些不太好的实践（或疏忽）会导致对象生命周期变得很长甚至导致OOM。
    - 减少成员变量、静态变量的使用。
  - Java中的内存泄漏并不是指物理内存而是指物理内存。
  - 常见内存泄露场景
    - 单例模式的不当使用，单例的生命周期喝应用程序是一样长的，如果单例对象持有外部对象的引用，就会导致这个外部对象不能被回收，从而导致内存泄漏
    - 一些提供`close()`的资源未关闭导致内存泄漏
      - 数据库连接`dataSource.getConnection()`、网络连接`socket`和IO连接必须手动关闭，否则是不能被回收。

#### Stop The World

- 在GC过程中，产生的应用程序的停顿
- 可达性分析算法为保证分析结果的准确性，分析工作必须在一个能够确保一致性的快照中进行。 

#### 垃圾回收的并发与并行

- 并行（Parallel）,指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。
- 串行（Serial），如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完再启动程序线程。
- 并发（Concurrent），指用户线程和垃圾回收线程同时执行（可能会交替执行）
  - 用户线程继续运行，而垃圾回收线程运行于另一个CPU上。
  - 如：CMS、G1

#### 安全点与安全区域

- 安全点`SafePoint`：程序执行时并非在所有地方都能停顿下来开始GC，只有在特定位置才能停顿下来开始GC，这些位置称为安全点。
- 安全点的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题，大部分指令的执行时间都非常短，通常会根据**是否具有让程序长时间执行的特征**为标准，比如选择一些执行时间较长的指令作为安全点，如：方法调用，循环跳转和异常跳转等。
- 安全区域（Safe Region）
  - 指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们可以把Safe Region看作是被扩展了的Safe Point。
  - 实际执行时
    - 当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会自动忽略表示为Safe Region状态的线程。
    - 当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止。

#### 引用类型

在`JDK1.2`版本之后，Java对引用的概念进行了扩充，依次如下。

##### 强引用（Strong reference）

- 类似`Object obj = new Object()`这种引用关系，无论在任何情况下，只要引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象。
- 强引用可以直接访问目标对象

##### 软引用(Soft reference)

- 在系统将要发生内存溢出之前，将会将这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出的异常。

- 软引用通常用来实现内存敏感的缓存，如：高速缓存就有用到软引用。

- 垃圾回收器在某个时刻决定回收可达对象的时候会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）

- ```java
      public static void main(String[] args) {
          //创建软引用
          SoftReference<Object> objectSoftReference = new SoftReference<Object>(new Object());
          //从软引用中获取强引用
          System.out.println(objectSoftReference.get());
          System.gc();
  
          System.out.println("After GC:");
          //系统内存足够，不会回收软引用可达的对象
          System.out.println(objectSoftReference.get());
  
          try {
              //构造系统内存不足场景
              byte[] bytes = new byte[7 * 1024 * 1024];
          } catch (Throwable e) {
              e.printStackTrace();
          } finally {
              //再次获取强引用
              //系统内存不足，报OOM之前会回收软引用可达的对象
              System.out.println(objectSoftReference.get());
          }
      }
  ```

##### 弱引用(Weak reference)

- 被弱引用关联的对象只能生存到下一次垃圾回收之前，当垃圾收集器工作时，无论空间是否足够，都会回收掉被弱引用关联的对象。
- 常用作缓存

```java
    public static void main(String[] args) {
        //创建弱引用
        Reference<Object> objectSoftReference = new WeakReference<>(new Object());
        //从弱引用中获取强引用
        System.out.println(objectSoftReference.get());
        System.gc();

        System.out.println("After GC:");
        //GC就会回收Weak引用可达的对象
        System.out.println(objectSoftReference.get());
    }
```



##### 虚引用、幽灵引用(Phantom reference) ----对象回收跟踪

- 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时得到一个系统通知。
- 虚引用必须和引用队列一起使用，虚引用创建时必须提供一个引用队列作为参数，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，用以通知应用程序对象的回收情况。
- 可以将一些资源释放操作放在虚引用中记录执行

```java
package com.example.demo.jvm.reference;

import java.lang.ref.PhantomReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;

public class PhantomReferenceTest {
    static PhantomReferenceTest phantom;
    //引用队列
    static ReferenceQueue<PhantomReferenceTest> phantomQueue;

    public static void main(String[] args) {
        Thread thread = new Thread(new CheckRefQueue());
        // 设为守护线程
        thread.setDaemon(true);
        thread.start();

        phantomQueue = new ReferenceQueue<>();
        phantom = new PhantomReferenceTest();

        // 构造PhantomReferenceTest对象的虚引用
        Reference<PhantomReferenceTest> phantomRef = new PhantomReference<>(phantom, phantomQueue);

        // 不可从虚引用中获取对象
        System.out.println(phantomRef.get());

        //去除强引用
        phantom = null;

        try {
            //第一次进行GC，由于对象在finalize方法中复活，GC无法回收该对象
            System.gc();
            // 由于GC线程优先级较低，休眠当前线程
            //更能确保GC线程能够执行
            Thread.sleep(1000);
            System.out.println("第一次GC后，phantom=" + phantom);

            Thread.sleep(1000);
            //当phantom被回收，会将虚引用加入引用队列
            phantom = null;
            System.gc();
            System.out.println("第二次GC结束");
            Thread.sleep(1000);
            System.out.println("第二次GC后，phantom=" + phantom);

        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalization");
        //可使对象复活
        phantom = this;
    }

    static class CheckRefQueue implements Runnable {

        @Override
        public void run() {
            while (true) {
                Reference<? extends PhantomReferenceTest> reference = phantomQueue.poll();
                if (null != reference) {
                    System.out.println("PhantomReferenceTest对象的虚引用被回收了，ref=" + reference);
                }

            }
        }
    }
}

```



##### 终结器引用

- 它用以实现对象的`finalize()`，也可以称为终结器引用
- 无需手动编码，其内部配合引用队列使用
- 在GC时，终结器引用入队列。由`Finalizer`线程通过终结器引用找到被引用对象并调用它的`finalize()`，第二次GC时才能回收引用对象。

## 本地方法接口（Native Interface）

## 字节码和类的加载

一个有效的字节码文件除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。

常量池可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法、参数类型和字面量等类型。

![字节码文件](C:\Users\MLY\Desktop\Markdown\字节码文件.png)



## 性能监控与调优

### 概述

### 性能优化步骤

1. 性能监控
2. 性能分析
3. 性能调优

### 性能评价指标

#### 停顿时间/响应时间

提交请求和返回该请求的响应之间使用的时间。

#### 吞吐量

单位时间内完成的工作量

#### 并发数

同一时刻，对服务器有实际交互的请求数

#### 内存占用

Java堆所占的内存大小

#### 相互间的关系

### JVM	监控及诊断工具-命令行篇

#### jps

查看正在运行的Java进程

#### jsat

查看JVM统计信息

` jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]`

- option

  - `class`：类的装载、卸载数量、总空间、类装载所消耗的时间等。

  ```bash
  C:\Users\MLY>jstat -class 20532
  Loaded  Bytes  Unloaded  Bytes     Time
    3989  7373.5        2     1.8       1.47
  ```

  - `gc`：显示与GC相关的堆信息，包括Eden区、S0、S1、老年代、永久代等的容量、已用空间、GC时间合计等信息。

  ```sh
  C:\Users\MLY>jstat -gc 20532
   S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
   0.0   5120.0  0.0   5120.0 57344.0  19456.0   189440.0    332.2    21504.0 20702.6 2560.0 2287.3      2    0.020   0      0.000    0.020

  ```

  ​

  - `gccapacity`：输出内容与`gc`基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。

  ```sh
  C:\Users\MLY>jstat -gccapacity 20532
   NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC
       0.0 786432.0  67584.0    0.0 4096.0  63488.0        0.0   786432.0   184320.0   184320.0      0.0 1071104.0  24064.0      0.0 1048576.0   2816.0      3     0
  ```

  ​

  - `gcutil`：内容与`gc`基本相同，但输出主要关注已使用空间占总空间的百分比

  ```sh
  C:\Users\MLY>jstat -gcutil 20532
    S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
    0.00 100.00   1.61   2.11  97.47  92.63      3    0.025     0    0.000    0.025
  ```

  ​

  - `gccause`：与`gcutil`功能基本相同，但会打印最后一次或正在进行的GC产生的原因

  ```sh
  C:\Users\MLY>jstat -gccause 20532
    S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC
    0.00 100.00   3.23   2.11  97.47  92.63      3    0.025     0    0.000    0.025 G1 Evacuation Pause  No GC
  ```

  ​

  - `gcnew`

  ```sh

  ```

  ​

  - `gcnewcapacity`

  ```sh

  ```

  ​

  - `gcold`

  ```sh

  ```

  ​

  - `gcoldcapacity`

  ```sh

  ```

  ​

  - `gcpermcapacity`

  ```sh

  ```

  ​

  - `compiler`：显示JIT编译器编译过的方法、耗时等信息。

  ```sh
  C:\Users\MLY>jstat -compiler 20532
  Compiled Failed Invalid   Time   FailedType FailedMethod
      2562      0       0     2.62          0
  ```

  ​

  - `printcompilation`：输出已经被JIT编译的方法

  ```sh
  C:\Users\MLY>jstat -printcompilation 20532
  Compiled  Size  Type Method
      2564     48    1 java/io/ObjectOutputStream$BlockDataOutputStream writeLong
  ```

  ​

- interval

  - 输出统计数据的间隔

- `-t`

  - 输出程序运行的总时间，单位秒

- count

  - 查询的总次数

#### jinfo

实时修改和查看JVM参数

```sh
Usage:
    jinfo [option] <pid>
        (to connect to running process)
    jinfo [option] <executable <core>
        (to connect to a core file)
    jinfo [option] [server_id@]<remote server IP or hostname>
        (to connect to remote debug server)

where <option> is one of:
    -flag <name>         to print the value of the named VM flag
    -flag [+|-]<name>    to enable or disable the named VM flag
    -flag <name>=<value> to set the named VM flag to the given value
    -flags               to print VM flags
    -sysprops            to print Java system properties,可通过System.getProperties()获取
    <no option>          to print both of the above
    -h | -help           to print this help message
```



#### jmap

导出内存映像文件&内存使用情况

```sh
Usage:
    jmap [option] <pid>
        (to connect to running process)
    jmap [option] <executable <core>
        (to connect to a core file)
    jmap [option] [server_id@]<remote server IP or hostname>
        (to connect to remote debug server)

where <option> is one of:
    <none>               to print same info as Solaris pmap
    -heap                to print java heap summary
    -histo[:live]        to print histogram of java object heap; if the "live"
                         suboption is specified, only count live objects
    -clstats             to print class loader statistics
    -finalizerinfo       to print information on objects awaiting finalization
    -dump:<dump-options> to dump java heap in hprof binary format
                         dump-options:
                           live         dump only live objects; if not specified,
                                        all objects in the heap are dumped.
                           format=b     binary format
                           file=<file>  dump heap to <file>
                         Example: jmap -dump:live,format=b,file=heap.bin <pid>
    -F                   force. Use with -dump:<dump-options> <pid> or -histo
                         to force a heap dump or histogram when <pid> does not
                         respond. The "live" suboption is not supported
                         in this mode.
    -h | -help           to print this help message
    -J<flag>             to pass <flag> directly to the runtime system
```



#### jhat

JDK自带堆分析工具

#### jstack

查看线程快照

#### jcmd

多功能命令行

```sh
C:\Users\MLY>jcmd 82112 help
82112:
The following commands are available:
JFR.stop
JFR.start
JFR.dump
JFR.check
VM.native_memory
VM.check_commercial_features
VM.unlock_commercial_features
ManagementAgent.stop
ManagementAgent.start_local
ManagementAgent.start
VM.classloader_stats
GC.rotate_log
Thread.print
GC.class_stats
GC.class_histogram
GC.heap_dump
GC.finalizer_info
GC.heap_info
GC.run_finalization
GC.run
VM.uptime
VM.dynlibs
VM.flags
VM.system_properties
VM.command_line
VM.version
help

For more information about a specific command use 'help <command>'.

C:\Users\MLY>jcmd 82112 GC.heap_info
82112:
 PSYoungGen      total 73728K, used 5229K [0x00000000f1700000, 0x00000000f6900000, 0x0000000100000000)
  eden space 63488K, 8% used [0x00000000f1700000,0x00000000f1c1b428,0x00000000f5500000)
  from space 10240K, 0% used [0x00000000f5f00000,0x00000000f5f00000,0x00000000f6900000)
  to   space 10240K, 0% used [0x00000000f5500000,0x00000000f5500000,0x00000000f5f00000)
 ParOldGen       total 105472K, used 4460K [0x00000000d4400000, 0x00000000dab00000, 0x00000000f1700000)
  object space 105472K, 4% used [0x00000000d4400000,0x00000000d485b310,0x00000000dab00000)
 Metaspace       used 21231K, capacity 21650K, committed 21936K, reserved 1069056K
  class space    used 2375K, capacity 2526K, committed 2560K, reserved 1048576K
```



#### jstatd

远程主机信息收集



### JVM监控及诊断工具-GUI篇

#### jconsole

用于对JVM内存、线程和类等的监控，是一个基于JMX（Java management extensions）的GUI性能监控工具

#### ![](C:\Users\MLY\Desktop\Markdown\picture\jconsole.jpg)

#### visualVM

它集成了多个JDK命令行工具，使用visualVM可以用于显示虚拟机进程的配置和环境信息（jps、jinfo），监视应用程序的CPU、GC、堆、方法区及线程的信息（jsta、jstack）等，甚至代替jconsole。

Visual VM可以独立安装。建议安装Visual GC插件

![](C:\Users\MLY\Desktop\Markdown\picture\jvisualvm连接方式.png)

#### MAT

- Shallow Heap（深堆）

  表示一个Java对象结构所占用内存的大小，Java对象内部包含三部分数据：对象头、实例数据和对齐填充。

  - 对象头，包含两部分：标记部分和原始对象引用。对象头大小未开启压缩是16byte，开启压缩是12byte（64位机器）。
    - 标记部分：包括hashcode、gc分代年龄、锁状态标志、线程持有锁、偏向锁线程锁ID、偏向时间戳。这部分在32位机器上是4byte，64位机器上是8byte。
    - 原始对象引用：是指对象的指针，通常这个指针找到对象的实例，该数据可以压缩，32机器上为4byte，64位机器上为8byte，`JDK8`默认开启压缩，大小为4byte。
  - 实例数据，指Java对象实例。
  - 对其填充，对齐填充要追根其根源，其实是到了计算机系统结构的学科。我在大学的时候学到了对齐填充，和这里是一样的道理。java中的对象都是以8个字节为单位对齐，所以每一个java对象的大小都是8的整数倍。


- Retained Heap（浅堆）

  表示一个Java对象被GC后可以真实释放的内存的大小。（一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。）

  - 保留集（Retained Set），对象A能直接或间接访问其他对象，这些对象的集合起来就是对象A的保留集。当进行垃圾回收的时候，不仅回收A也会回收保留集中所有的对象。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200117134526989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NERERMTEw=,size_16,color_FFFFFF,t_70)

A引用了对象C,D，对象B引用了对象C,E。

对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。

而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。

## 线程

## 直接内存

- 不是虚拟机运行时数据的一部分，也不是《Java虚拟机规范》中定义的内存区域
- 直接内存不是在Java堆上的，是直接向系统申请的内存空间。
- 来源于`NIO`通过堆中的`DirectByteBuffer`操作本地内存。

- 通常访问直接内存的速度会优于Java堆，即读写性能高。
  - 因此出于性能考虑，读写频繁的场景可能会考虑使用直接内存
  - Java的`NIO`库允许Java程序使用直接内存,用于数据缓冲区。



## 面试

