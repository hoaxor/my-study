# Oracle

## 性能调优

### **选择性、基数**

### 解析基础：

执行SQL语句时，Oracle都会对其执行以下操作

1、验证语法

2、验证语句中引用的对象

3、分配给执行作业的用户权限

4、验证if语句在共享池中已经可用。Oracle引擎将计算SQL语句的hash并查找

5、如果语句不存在，则分配共享内存并在共享池中创建游标

6、生成执行计划

### 解析类型：

1. Hard Parse：这意味着该语句在共享内存中不可用，如果共享池很小，那么也可能需要硬解析，硬解析需要额外的系统资源这也称为“库缓存未命中”。

2. Soft Parse：意味着该语句已经执行过，所以 Oracle 只需要按照上面提到的步骤 1-3 执行，因为其余的任务已经在前面完成了。就像努力一次，收获多次。这也称为“库缓存命中”，因为您已解析语句并可在库缓存中使用。

硬解析应保持在最低要求有两个关键原因：

1. 执行计划的生成是一个非常耗费 CPU 的操作。
2. 共享池中的内存是有限的，并且内存操作也是序列化的。内存操作使用共享池锁存器发生，如果发生如此多的硬解析，那么数据库中的其他进程将不得不在队列中等待以获得共享池锁存器。因此，硬解析会影响共享池锁和库缓存锁的数量。

### 游标

对于您执行的每条 SQL 语句，Oracle 引擎都会生成两个游标：父游标和子游标。生成两个游标是因为对于同一个 SQL 语句，可能存在其他差异，例如可能存在不同的绑定值或两个不同的架构或不同的文字值等。父游标将保存 SQL 语句，子游标将保存信息与差异有关。这实质上使子游标成为决定 SQL 语句将进行硬解析还是软解析的决定因素。

#### 父游标

- 它存储游标的 SQL 文本。当两个语句逐字相同时，它们将共享相同的父光标。
- 每个父游标都将在为其创建至少一个子游标的情况下执行。
- 父游标在视图 V$SQLAREA 中表示。v$sqlarea 中的 VERSION_COUNT 列可以告诉我们这个父游标有多少子游标。

#### 子游标

- 每个父级至少有一个子游标，也可以有多个子游标
- 父游标存储 SQL 文本，子游标存储与 SQL 语句相关的其他重要信息，例如：环境详细信息、统计详细信息、绑定变量详细信息、执行计划详细信息、绑定变量详细信息。
- 子游标占用较少的内存空间，因为 SQL 文本不存储在子游标中
- 每个子游标必须属于父游标
- 子游标决定查询将经历硬解析还是软解析。您可能会发现两条语句的 SQL 查询相同，因此父游标相同但子游标不可共享给 SQL 进行硬解析（重新编译）。
- 父游标在视图 V$SQL 中表示
- V$SQL_SHARED_CURSOR 是非常有用的视图，因为它提供了优化器决定将游标标记为非共享的原因。因此，每当您看到 SQL 语句相同并且仍然发生硬解析时，请查看此视图。



## 锁

ORACLE的数据库锁分为以下几大类：

1. DML锁（data locks数据锁），用于保护数据的完整性；
2. DDL锁（dictionary locks字典锁），用于保护数据库对象的结构，例如表、索引的结构定义；
3. 内部锁或闩（internal locks or latches），用于保护内部结构

在Oracle数据库中，DML锁主要包括TM锁和TX锁，其中TM锁称为表级锁，TX锁称为事务锁或行级锁。

当Oracle执行DML语句时，系统自动在所要操作的表上申请TM类型的锁。当TM锁获得后，系统再自动申请TX类型的锁，并将实际锁定的数据行的锁标志位进行置位。这样在事务加锁前检查TX锁相容性时就不用再逐行检查锁标志，而只需检查TM锁模式的相容性即可，大大提高了系统的效率。TM锁包括了SS、SX、S、X 等多种模式，在数据库中用0－6来表示。不同的SQL操作产生不同类型的TM锁。

ORACLE里锁有以下几种模式: 

0：none 
1：null 空 
2：Row-S 行共享(RS)：共享表锁，sub share 
3：Row-X 行独占(RX)：用于行的修改，sub exclusive 
4：Share 共享锁(S)：阻止其他DML操作，share 
5：S/Row-X 共享行独占(SRX)：阻止其他事务操作，share/sub exclusive 
6：exclusive 独占(X)：独立访问使用，exclusive

在数据行上只有X锁（排他锁）。在 Oracle数据库中，当一个事务首次发起一个DML语句时就获得一个TX锁，该锁保持到事务被提交或回滚。当两个或多个会话在表的同一条记录上执行 DML语句时，第一个会话在该条记录上加锁，其他的会话处于等待状态。当第一个会话提交后，TX锁被释放，其他会话才可以加锁。

当Oracle数据库发生TX锁等待时，如果不及时处理常常会引起Oracle数据库挂起，或导致死锁的发生，产生ORA-60的错误。这些现象都会对实际应用产生极大的危害，如长时间未响应，大量事务失败等。



