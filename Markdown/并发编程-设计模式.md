# 并发编程-设计模式

## 同步模式之保护性暂停

即Guarded Suspension，用在另一个线程等待另一个线程的执行结果。

- 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个`GuradedObject`
- 如果有结果不断从一个线程到另一个线程那么可以使用消息队列。
- JDK中，`join`、`Future`的实现，采用的就是此模式
- 因为要等待另一方的结果，因此归类到同步模式

![](C:\Users\11690\Desktop\Markdown\picture\同步模式之保护性暂停.jpg)

### join原理

join就是保护性暂停模式的运用

```java
    public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
```



### 保护性暂停模式

#### 简单运用

```java
@Slf4j(topic = "guardedTest")
public class GuardedSuspensionTest {
    public static void main(String[] args) {
        test4();
    }

    /**
     * 无超时时间
     */
    static void test1() {
        GuardedObject<String> guardedObject = new GuardedObject<>();
        new Thread(() -> {
            log.debug("start get");
            String response = guardedObject.getResponse();
            log.debug(response);
        }, "t1").start();

        new Thread(() -> {
            log.debug("start read");
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            String s = read("C:\\Users\\11690\\Desktop\\统计导出生产问题排查.sql");
            guardedObject.setResponse(s);
        }, "t2").start();
    }

    /**
     * 未超时返回
     */
    static void test2() {
        GuardedObject<String> guardedObject = new GuardedObject<>();
        new Thread(() -> {
            log.debug("start get");
            String response = guardedObject.getResponse(2000);
            log.debug(response);
        }, "t1").start();

        new Thread(() -> {
            log.debug("start read");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            String s = "hello";
            guardedObject.setResponse(s);
            log.debug("end");
        }, "t2").start();
    }

    /**
     * 超时返回
     */
    static void test3() {
        GuardedObject<String> guardedObject = new GuardedObject<>();
        new Thread(() -> {
            log.debug("start get");
            String response = guardedObject.getResponse(2000);
            log.debug(response);
        }, "t1").start();

        new Thread(() -> {
            log.debug("start read");
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            String s = "hello";
            guardedObject.setResponse(s);
            log.debug("end");
        }, "t2").start();
    }

    /**
     * 未超时返回null
     */
    static void test4() {
        GuardedObject<String> guardedObject = new GuardedObject<>();
        new Thread(() -> {
            log.debug("start get");
            String response = guardedObject.getResponse(2000);
            log.debug(response);
        }, "t1").start();

        new Thread(() -> {
            log.debug("start read");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            String s = null;
            guardedObject.setResponse(s);
            log.debug("end");
        }, "t2").start();
    }


    static String read(String path) {
        Reader reader = null;
        StringBuilder sb = new StringBuilder();
        try {
            reader = new BufferedReader(new FileReader(path));
            char[] chars = new char[1024];
            while (reader.read(chars) > 0) {
                sb.append(chars);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (null != reader) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return sb.toString();
    }

}

class GuardedObject<T> {
    private T response;

    /**
     * 无限等待
     */
    public T getResponse() {
        synchronized (this) {
            while (response == null) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return response;
        }
    }

    /**
     * 设置超时时间
     */
    public T getResponse(long timeOut) {
        synchronized (this) {
            long waited = 0;
            long start = System.currentTimeMillis();
            while (response == null) {
                long waitTime = timeOut - waited;
                if (waitTime <= 0) {
                    break;
                }
                try {
                    this.wait(waitTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                waited = System.currentTimeMillis() - start;
            }
            return response;
        }
    }

    public void setResponse(T response) {
        synchronized (this) {
            this.response = response;
            this.notifyAll();
        }
    }
}
```



#### 保护性暂停模式增强

![](C:\Users\11690\Desktop\Markdown\picture\同步模式之保护性暂停增强.png)

```java
@Slf4j(topic = "guardedTest2")
public class GuardedSuspensionTest2 {
    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 3; i++) {
            new Thread(new People()).start();
        }
        //休眠1s避免无快递员送信，收信人一直等待的情况
        TimeUnit.SECONDS.sleep(1);
        for (Integer id : MailBoxes.getIds()) {
            new Thread(new Postman(id, "hello" + id)).start();
        }

    }


}

@Slf4j(topic = "postman")
class Postman implements Runnable {

    private Integer id;

    private String mail;

    public Postman(int id, String mail) {
        this.id = id;
        this.mail = mail;
    }

    @Override
    public void run() {
        GuardedObject2<String> guardedObj = MailBoxes.getGuardedObj(this.id);
        log.debug("开始送信，ID={}", guardedObj.getId());
        guardedObj.setResponse(mail);
    }
}

@Slf4j(topic = "people")
class People implements Runnable {
    @Override
    public void run() {
        GuardedObject2<String> obj = MailBoxes.createGuardedObj();
        log.debug("开始收信，ID={}", obj.getId());
        String response = obj.getResponse();
        log.debug("收到信，ID={}，内容={}", obj.getId(), response);
    }
}

class MailBoxes {
    private static final Map<Integer, GuardedObject2<String>> boxes = new Hashtable<>();

    private static int id = 0;

    private static synchronized int generateId() {
        return id++;
    }

    public static GuardedObject2<String> createGuardedObj() {
        GuardedObject2<String> obj = new GuardedObject2<>(generateId());
        boxes.put(obj.getId(), obj);
        return obj;
    }

    public static Set<Integer> getIds() {
        return boxes.keySet();
    }

    public static GuardedObject2<String> getGuardedObj(Integer id) {
        return boxes.remove(id);
    }

}

class GuardedObject2<T> {

    private int id;

    private T response;

    public GuardedObject2(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }

    /**
     * 无限等待
     */
    public T getResponse() {
        synchronized (this) {
            while (response == null) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return response;
        }
    }

    /**
     * 设置超时时间
     */
    public T getResponse(long timeOut) {
        synchronized (this) {
            long waited = 0;
            long start = System.currentTimeMillis();
            while (response == null) {
                long waitTime = timeOut - waited;
                if (waitTime <= 0) {
                    break;
                }
                try {
                    this.wait(waitTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                waited = System.currentTimeMillis() - start;
            }
            return response;
        }
    }

    public void setResponse(T response) {
        synchronized (this) {
            this.response = response;
            this.notifyAll();
        }
    }
}
```



## 同步模式指顺序控制

### 按顺序执行

2个线程依次输出1、2

#### wait/notify版本

```java
    static boolean hasExecuted = false;

    public static void test1() {
        final Object lock = new Object();
        new Thread(() -> {
            while (!hasExecuted) {
                synchronized (lock) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
            log.debug("2");
        }).start();

        new Thread(() -> {
            synchronized (lock) {
                log.debug("1");
                hasExecuted = true;
                lock.notify();
            }
        }).start();
    }
```

#### condition版本

```java
```

#### park/unpark版本

```java
    public static void test2() {
        Thread thread = new Thread(() -> {
            LockSupport.park();
            log.debug("2");
        });
        thread.start();

        new Thread(() -> {
            log.debug("1");
            LockSupport.unpark(thread);
        }).start();
    }
```
### 交替执行

a、b、c三个线程，a输出5次a，b输出5次b，c输出5次c，最终程序输出的结果为`abcabcabcabcabc`



## 同步模式之Balking

Balking（犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回

```java
@Slf4j(topic = "balking")
public class BalkingTest {
    //标识是否已经执行过start
    private boolean flag;

    public void start() {
        //防止并发问题
        synchronized (this) {
            if (flag) {
                return;
            }
            flag = true;
        }

        log.debug("do something");
    }
}
```







## 异步模式之生产者/消费者

### 要点

- 与保护性暂停模式的`GuradedObject`不同，不需要产生结果和消费结果的线程一一对应
- 消费队列可以用来平衡生产和消费的线程资源
- 生产者仅负责产生结果数据，不关心数据如何处理，而消费者专心处理结果数据
- 消息队列是有容量限制的，满时则不会加入数据，空时不会再消费数据
- JDK中各种阻塞队列，采用的就是这种模式

![](C:\Users\11690\Desktop\Markdown\picture\异步模式之生产者消费者.jpg)



```java
@Slf4j(topic = "pctest")
public class ProducerConsumerTest {
    public static void main(String[] args) {
        MessageQueue<String> messageQueue = new MessageQueue<>(2);
        for (int i = 0; i < 3; i++) {
            int finalId = i;
            new Thread(() -> {
                messageQueue.put(new Message<>(finalId, "data" + finalId));
            }, "p" + i).start();
        }

        new Thread(() -> {
            while (true) {
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                Message<String> take = messageQueue.take();
            }
        }, "c0").start();
    }
}

class Message<T> {
    private final int id;

    private final T data;

    public Message(int id, T data) {
        this.id = id;
        this.data = data;
    }

    public int getId() {
        return id;
    }

    public T getData() {
        return data;
    }

    @Override
    public String toString() {
        return "Message{" +
                "id=" + id +
                ", data=" + data +
                '}';
    }
}

@Slf4j(topic = "messageQueue")
class MessageQueue<T> {

    private final LinkedList<Message<T>> messageList;

    private final int capacity;

    public MessageQueue(int capacity) {
        this.messageList = new LinkedList<>();
        this.capacity = capacity;
    }

    public Message<T> take() {
        synchronized (messageList) {
            while (messageList.isEmpty()) {
                log.debug("message is empty,cant take");
                try {
                    messageList.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // 从头取
            Message<T> tMessage = messageList.removeFirst();
            log.debug("take message {}", tMessage);
            //唤醒所有wait线程，目的是唤醒生产者生产
            messageList.notifyAll();
            return tMessage;
        }
    }

    public void put(Message<T> message) {
        synchronized (messageList) {
            while (messageList.size() >= capacity) {
                log.debug("message is full,cant put");
                try {
                    messageList.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //从尾进
            messageList.addLast(message);
            log.debug("put message {}", message);
            //唤醒所有wait线程，目的是唤醒消费者消费
            messageList.notifyAll();
        }
    }

}
```



## 享元模式

### 简介

Flyweight pattern，当需要重用数量有限的同一对象时

> wikipedia:
>
> the **flyweight** [software design pattern](https://en.wikipedia.org/wiki/Design_pattern_(computer_science)) refers to an [object](https://en.wikipedia.org/wiki/Object_(computer_science)) that minimizes [memory](https://en.wikipedia.org/wiki/Computer_memory) usage by sharing some of its data with other similar objects. 



### JDK体现

#### 包装类

在`JDK`中`Boolean`、`Byte`、`Short`、`Integer`、`Long`、`Character`等包装类提供了`valueOf`方法

例如`Long`的`valueOf`方法

```java
    public static Long valueOf(long l) {
        final int offset = 128;
        if (l >= -128 && l <= 127) { // will cache
            return LongCache.cache[(int)l + offset];
        }
        return new Long(l);
    }
```



#### String

#### BigDecimal、BigInteger



### 自定义

例如：一个线上商城，`QPS`达到上千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响，这时预先创建好一批连接，放入连接池。每次连接都从连接池获取，使用完毕后再还回连接池，这样既节约了连接创建和关闭的时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库

```java
```

以上实现没有考虑

- 连接的动态增长与收缩
- 连接保活（可用性检测）
- 等待超时处理
- 分布式hash

对于关系型数据库，可以使用`c3p0`、`druid`等

对于通用的对象池，可以考虑使用apache commons pool，例如`redis`连接池可以参考`jedis`中关于连接池的实现





