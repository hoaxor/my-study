# JVM

跨语言的平台

Java编译器输入的指令流基本上是一种基于栈的指令集架构

java文件-》字节码-》机器码

虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而**虚拟机的执行引擎是由软件自行实现的**，因此可以不受物理条件制约地定制执行引擎的体系结构，**能够执行那些不被硬件直接支持的指令集格式**。

## 类加载子系统（Class Loader Subsystem）

### 加载（loading）

1. 通过一个类的全限定名获取此类的二进制字节流
2. 将字节流所代表的静态数据结构转化为方法区运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区的各种数据的访问入口

类来源：本地、网络、zip包、运行时生成（动态代理）、有其他文件生成（JSP等）、数据库、加密文件（防止反编译）

### 链接（linking）
1. #### 验证（verify）
   
    确保class字节码文件的字节流包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全
    主要包括四种验证：文件格式、元数据、字节码、符号引用
2. #### 准备（prepare）
   
    为类变量分配内存并初始化（static修饰的），不包含（final static修饰的），因为final在编译的时候就分配了，准备阶段会显示初始化
3. #### 解析（resolve）
   
    将常量池内的符号引用转为为直接引用
    事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行
    **符号引用**就是一组描述所引用的目标，符号引用的字面量形式明确定义在《Java虚拟机规范》的class文件格式中。
    **直接引用**就是直接指向目标的指针、相对偏移量或者简介定位到目标的句柄
    解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的`CONSTANT_Class_info`、`CONSTANT_Feildref_info`、`CONSTANT_Methodref_info`等。


### 初始化（initialization）

1. 执行类构造器方法<cinit>()。
2. 此方法不需要定义是javac编译器收集类中所有类变量的赋值动作和静态代码块的语句合并而来，
3. 构造器方法中指令按语句在源码中出现的顺序执行。
4. <cinit>()不同于类的构造器（<init>()）。
5. 若该类有父类，JVM会保证父类的<cinit>()在子类<cinit>()前执行
6. 虚拟机保证一个类的<cinit>()方法在多线程下被同步加锁。

### 类加载器

#### `Bootstrap CLassLoader`（引导类加载器、启动类加载器）

C/C++实现，嵌套在JVM内部（JVM的一部分）。用于加载核心类库，如JAVA_HOME/jre/lib/rt.jar、resources.jar等。出于安全考虑，它只加载报名为Java、javax、sun等开头的类。

#### `User-Define CLassLoader`（用户自定义类加载器）

##### `Extension CLassLoader`（扩展类加载器）

java语言编写，派生于ClassLoader，父类加载器为启动类加载器，从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK安装目录的jre/lib/ext子目录下加载类库，**用户自定义的jar放在此目录下也会被扩展类加载器加载**

##### AppClassLoader（应用类加载器）

java语言编写，派生于ClassLoader，父类加载器为扩展类加载器，它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库，一般来说，Java应用的类都是由它来完成加载。

##### 自定义类加载器

应用场景：隔离加载类（不同类库类名冲突的情况）、修改类加载的方式、扩展加载源、防止源码泄露

##### 双亲委派机制（parents delegation）

1. 一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；

2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归请求最终将到达顶层的启动类加载器；

3. 如果父类加载器可以完成类加载任务，就返回成功，倘若父类加载器无法完成加载任务，子类加载器才会尝试自己去加载。

   ###### 自定义类加载器的优势

   1. 避免类重复加载
   2. 保护程序安全，防止核心`API`被恶意篡改

   ##### 沙箱安全机制

   ##### 类的主被动使用

   主动使用七种场景

   1. 创建类实例
   2. 访问或修改类或接口的静态变量
   3. 调用类静态方法
   4. 反射
   5. 初始化一个类的子类
   6. Java虚拟机启动时被标记为启动类的类
   7. JDK 7 提供带动态语言支持。。。

   被动使用不会不会导致类的初始化



## 内存与垃圾回收


### 运行时数据区（Runtime Data Area）

#### 方法区（Method Area）

- Non-Heap，独立于堆的内存空间。线程间共享的内存区域。
- 方法区在`JVM`启动的时候被创建，并且它的实际的物理内存空间可以是不连续的。
- 可以固定大小或可扩展。
- 错误：`java.lang.OutOfMemoryError: PermGen space`或`java.lang.OutOfMemoryError: Metaspace `
- 关闭`JVM`就会释放这个区域
- 用于存储已被JVM加载的类型信息、域(Filed)信息、常量、静态变量、即时编译后的代码缓存等。
  - 类型信息
    1. 这个类型的有效名称（包名+类名）
    2. 这个类型的直接父类的完整有效名（对于interface或是Java.lang.Object都没有父类）
    3. 这个类型的修饰符（public、abstract、final的某个子集）
    4. 这个类型的直接接口的一个有序列表
  - 域信息
    1. 域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient的某个子集）
  - 方法信息
    1. 方法名称
    2. 方法的返回类型
    3. 方法参数的数量和类型（按顺序）
    4. 方法的修饰符（public、private、protected、static、synchronized，native、abstract的一个子集）
    5. 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
    6. 异常表（abstract和native方法除外）
       - 每个异常的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。
  - non-final的类变量
    1. 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分。
    2. 类变量被类的所有实例共享，即使没有类实例时你也可以访问它。
  - static final 全局常量
    1. 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。
  - 运行时常量池
    - 常量池表
      1. 数值
      2. 字符串值
      3. 类引用
      4. 字段引用
      5. 方法引用
    - 常量池表是字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池。
    - 在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
    - JVM为每个已经加载的类型（类或接口）都维护一个常量池。池中的数据项就像数组项一样，是通过索引访问的。
    - 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。
      - 运行池常量池相对于Class文件常量池的另一个重要特征是：具备动态性。
    - 运行时常量池类似于传统编程语言中的符号表（symbol table），但它包含的数据却比符号表要更加丰富一些。
    - 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛出OOM异常。
- 方法区垃圾回收
  - 《Java虚拟机规范》对方法区的约束非常宽松，提到过可以不要求虚拟机在方法区中实现垃圾回收。
  - 方法区垃圾收集主要回收两部分的内容：常量池中废弃的常量和不再使用的类型。
  - 判断一个常量是否“废弃”还是相对简单，而要判断一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足以下三个条件
    - 该类的所有实例都已被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
    - 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGI，JSP的重加载，否则通常是很难达成的。
    - 该类对应的`java.lang.Class`对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。
  - JVM允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，`HotSpot`虚拟机提供了`-Xnoclassgc`参数进行控制，还可以使用`-verbose:class`以及`-XX:+TraceClass-Loading`、 `-XX:+TraceClassUnloading`查看类的加载和卸载信息。
  - 在大量使用反射、动态代理、`CGLib`等字节码框架，动态生成JSP以及OSGI这类频繁自定义类加载器的场景中，通常都需要JVM具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。



##### 永久代`JDK1.7`/元空间`JDK1.8`

- 永久代
  - 通过`-XX:PermSize`来设置永久代初始分配空间，默认值20.75`M`
  - `-XX:MaxPermSize`来设置永久代最大可分配空间。32位机器默认是64`M`，64位机器默认是82`M`
  - 异常：`java.lang.OutOfMemoryError: PermGen space`
  - `JDK1.6`及之前静态变量存放在永久代上
  - `JDK1.7`已经逐步“去永久代”，字符串常量池、静态变量移除，保持在堆中。
    - `JDK7`中将字符串常量池放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会触发，而`FG`是老年代、永久代空间不足时才会触发，这就导致`StringTable`回收效率不高。而我们在开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆中能及时回收。
    - 永久代空间小
- 元空间
  - 元空间大小可以使用参数`-XX:MetaspaceSize`和`-XX:MaxMetaspaceSize`指定替换原有的永久代的参数
  - 默认值依赖于平台，Windows下，`-XX:MetaspaceSize`是21`M`，`-XX:MaxMetaspaceSize`的值是-1，即没有限制。
  - 异常：`java.lang.OutOfMemoryError: Metaspace `
  - `-XX:MetaspaceSize`设置初始的元空间大小，对于一个64位的服务器端JVM来说，其默认的`-XX:MetaspaceSize`值为21`M`，这就是初始的**高水位线**，一旦触及这个水位线，Full GC将会被触发并卸载没用的类，然后这个高水位线将会重置，新的高水位线的值取决于GC后释放了多少元空间，如果释放的空间不足，那么在不超过`MaxMetaspaceSize`时，适当提高该值，如果释放过多，则适当降低该值。
  - 如果初始化的高水位线设置过低，**高水位线**调整情况会发生很多次，通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁的GC，建议将`-XX:MetaspaceSize`设置为一个相对较高的值。
  - 类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆。
- 元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。
- 永久代移除的原因
  - 永久代设置空间大小是很难确定的。
  - 对永久代调优是很困难的。

#### 堆（Heap）

##### 概念

- 一个JVM只存在一个堆，堆也是Java内存管理的核心区域。
- Java堆在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大的一块内存空间。
- 堆的大小可以调节
- 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
- 所有的线程共享Java堆，在这里还可以会分为线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。
- 《Java虚拟机规范》中对堆的描述，堆是运行时数据区，所有class实例和array的内存都是从改区域分配的。
- `JDK7`及之前版本堆内存逻辑上分为新生代`Young generation`+老年代`Old generation`+永久代`PermGen`；`JDK8`及之后版本堆内存逻辑上分为新生代+老年代+元空间`MetaSpace`
- 工具 `JVisualVM`插件`Visual GC `


##### 新生代老年代

年轻代：Eden区+ Survivor0 空间+Survivor1空间（也叫from区、to区），S0、S1只会有一个空间存储数据。

- 配置新生代与老年代在堆结构的占比（命令行：`jinfo -flag NewRatio pid `）
  - 默认 `-XX:NewRatio=2`，表示新生代占1，老年代占2，新生代占整个堆的1/3。
  - 修改 `-XX:NewRatio=4`，表示新生代占1，老年代占4，新生代占整个堆的1/5。
- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是`8:1:1`
  - 可以使用`-XX:SurvivorRatio`调整这个空间比例（命令行：`jinfo -flag SurvivorRatio pid`）。
- 几乎所有的Java对象都是在Eden区被new出来的。
- 绝大多数的Java对象的销毁都在新生代进行。
- 可以使用`-Xmn`设置新生代最大内存大小
  - 这个参数一般使用默认值即可。

##### 堆空间设置参数

`-Xms`堆区的起始内存等价于`-XX:InitialHeapSize`，`-Xmx`堆区的最大内存等价于`-XX:MaxHeapSize`

- 一旦堆区的内存大小超过`-Xmx`最大内存所指定的值，将会抛出OutOfMemoryError。
- 通常会将起始内存大小和最大内存大小两个参数配置相等的值，目的是能够在Java垃圾回收机制清理完堆空间后不需要重新分隔计算堆区的大小，从而提升性能。
- 默认情况下，初始内存大小：物理内存 / 64；最大内存大小：物理内存 / 4。

##### 对象分配过程

- Eden区满了会触发YGC/Minor GC，Eden区幸存的对象迁移到幸存者区且幸存对象年龄加一，幸存者区满了不会触发YGC/Minor GC，YGC/Minor GC也会同时对幸存者区进行GC。
- 幸存者区S0、S1复制之后交换，谁空谁是to区。

- S0区到S1区幸存对象的年龄也会加一。
- 若新生代（Eden区、S0、S1）存储不下的对象则直接放到老年代，老年代放不下会触发FGC，FGC后仍然放不下会抛出OOM错误。
- 年轻代中的对象年龄达到阈值后晋升（Promotion）到老年代（默认阈值：15，可通过`-XX:MaxTenuringThreshold=N`调整）。
- 频繁在年轻代收集，很少在老年收集，几乎不在永久代/元空间收集。 

##### GC

JVM在进行GC时，并非每次都对新生代、老年代和方法区一起回收。大部分时候回收的都是新生代。

HotSpot VM的实现S，GC按照回收区域又分为两大种类，一种是部分收集（Partial GC），一种是整堆收集（Full GC）。

###### Partial GC

- Young GC/Minor GC
  - 新生代的垃圾回收
  - 当年轻代空间不足时，就会触发Minor GC，Eden区满会触发，Survivor区满不会触发。Minor GC会清理Eden区和Survivor区的内存。
  - Minor GC会引发STW（Stop The World），暂停其他的用户线程，等待垃圾回收结束，用户线程才恢复运行。

- Major GC
  - 老年代的垃圾回收，目前只有CMS GC会有单独收集老年代的行为
  - 出现Major GC，经常会伴随至少一次的Minor GC（但非绝对的），当老年代空间不足时，会先尝试触发Minor GC。如果空间还不足则触发Major GC
  - Minor GC的速度一般会比Major GC快10倍以上，STW的时间更短。
  - Major GC后，内存还不足，就报OOM。

- Mixed GC
  - 收集整个新生代以及部分老年代的垃圾回收，目前只有G1 GC会有这种行为

###### Full GC

- FGC
  - 收集整个Java堆和方法区的垃圾收集
  - 触发机制：调用`System.gc()`时，系统建议执行FGC，但是不必然执行；老年代空间不足；方法区空间不足；通过Minor GC后进入老年代的平均大小大于老年代的可用内存；由Eden区、S0（From space）向S1（To space）复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。   


##### 堆空间分代思想

分代唯一的理由就是优化GC的性能。

##### 内存分配策略

- 优先分配到Eden区
- 大对象直接分配到老年代
  - 尽量避免程序中出现过多的大对象
- 长期存活的对象分配到老年代
- 动态对象年龄判断
  - 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor区空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到`MaxTenuringThreshold`中要求的年龄。
- 空间分配担保设置
  - `-XX:HandlePromotionFailure`
    - 在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。
      - 如果大于，则此次Minor GC是安全的。
      - 如果小于，则虚拟机会查看`-XX:HandlePromotionFailure`设置值是否允许担保失败。
        - 如果`HandlePromotionFailure=true`，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。
          - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
          - 如果小于，则改为进行一次Full GC。
        - 如果`HandlePromotionFailure=false`，则改为进行一次Full GC。
    - `JDK6 Update24`之后，`HandlePromotionFailure`参数不会再影响虚拟机的空间分配担保策略，`JDK6 Update24`之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。

##### 常用内存参数

- 打印GC详细信息：`-XX:+PrintGCDetails`

![PrintGCDetails详解](C:\Users\11690\Desktop\MarkDown\20200314215636987.png)

- 查看所有参数的默认初始值：`-XX:+PrintFlagsInitial`
- 查看所有参数的最终值（可能会存在修改，不再是初始值）：`-XX:PrintFlagsFinal`
- 

##### TLAB（Thread Local Allocation Buffer）

- 产生原因
  - 堆区是线程共享区域，任何线程都可以访问到堆区的共享数据
  - 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。
  - 为避免多个线程操作同一个地址，需要使用加锁等机制，进而影响分配速度。
- 定义
  - TLAB是从内存模型而不是垃圾回收的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden区空间内。
  - 多线程同时分配内存时，使用TLAB可以避免一系列的线程安全问题，同时还能提高内存分配的吞吐量，因此我们可以将这种内存分配方式称为*快速分配策略*

- 说明
  - 尽管不是所有对象的实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。
  - 通过`-XX:UseTLAB`设置是否开启TLAB空间
  - 默认情况下，TLAB空间的内存非常小，仅占用整个Eden空间的1%，我们可以通过`-XX:TLABWasteTargetPercent`参数设置TLAB空间所占用的Eden空间的百分比大小。
  - 一旦对象在TLAB空间分配失败时，JVM就会尝试通过使用*加锁机制*确保数据操作的原子性，从而直接在Eden空间中分配内存。

##### 常用调优工具

- JDK命令行
- Eclipse MAT
- JConsole
- Visual VM
- JProfiler
- Java Flight Recorder
- GC Viewer
- GC Easy

##### 堆是分配对象存储的唯一选择吗？

随着`JIT `编译期的发展与`逃逸分析（Escape Analysis）`技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化。所有对象都分配在堆上也渐渐变得不那么*绝对*了。

###### 逃逸分析

- 一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无需进行垃圾回收了。
- 逃逸分析的基本行为就是分析对象动态作用域：
  - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
  - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。
- 参数设置
  - 在`JDK 6u23`之后`HotSpot`中默认就开启了逃逸分析。
  - 如果使用的是较早的版本，开发人员则可以通过：
    - `-XX:+DoEscapeAnalysis`显示开启逃逸分析
    - `-XX:+PrintEscapeAnalysis`查看逃逸分析的筛选结果
- 逃逸分析技术并不成熟，原因是无法保证逃逸分析的性能消耗一定高于它的性能，逃逸分析需要经过一系列复杂的分析，也是一个相当耗时的过程。

##### 基于逃逸分析的代码优化

- 栈上分配
  - 如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。
- 同步省略
  - 如果一个对象只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
  - 可以提高程序的并发性和性能
  - 在动态编译同步块时，`JIT`编译器可以借助逃逸分析来判断同步块所使用的锁对象只能够被一个线程访问而没有发布到其他线程。那么`JIT`编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消同步的过程就叫同步省略，也叫锁消除。 
- 分离对象或标量替换
  - 有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。
  - 标量（Scalar），是指一个无法再分解成更小的数据的数据。Java中原始数据类型就是标量。相对的，那些可以分解的数据叫聚合量（Aggregate），Java中的对象就是聚合量。
  - 在`JIT`阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过`JIT`优化，就会把这个对象拆解成若干个成员变量来代替。这个过程就叫标量替换。
  - 标量替换为栈上分配提供了基础
  - 可以大量减少内存的占用（无需创建对象，就不需要分配堆内存了）。
  - 标量替换设置参数使用`-XX:+EliminateAllocations`开启标量替换（默认打开），允许将对象打散分配在栈上。


#### 虚拟机栈（VM Stack）

- 概述

由于跨平台的设计，Java的指令都是根据栈来设计的，不同平台CPU架构不同，所以不能设计为基于寄存器的。

优点是，指令集小，编译器容易实现。缺点是性能下降，实现同样的功能比基于寄存器的需要更多的指令。

线程私有的，主管Java程序的运行，它保存方法的局部变量（八种基本数据类型和对象引用的地址（指向堆空间））、部分结果，并返回方法的调用和返回。

访问速度仅次于程序计数器。

JVM规范允许栈的大小是动态的或固定不变的,可用**-Xss**参数调节，示例：`-Xss1m`、`-Xss1024k`。

异常：`StackOverflowError`

- 栈帧（stack frame）

虚拟机栈的基本单位，线程中每个方法对一个栈帧，方法调用对应入栈（压栈）PUSH，方法返回对应出栈POP。在一个活动的线程中，一个时间点，只有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为**当前栈帧（Current Frame）**，与当前栈帧对应的方法就是**当前方法（Current Method）**,定义这个方法的类就是**当前类（Current Class）**

执行引擎运行的所有字节码指令只针对当前栈帧进行操作。

如果在该方法中调用了其他方法，对应新的栈帧会被创建出来，放在栈顶，成为新的**当前帧**

Java方法有两种返回函数的方式，一种是正常的函数返回，使用return 指令；另一种是抛出异常。不管哪种方式都会导致栈帧被弹出。

* **局部变量表（Local Variables）**

局部变量表也被称为局部变量数组或本地变量表

定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用以及return Address类型。

局部变量表中最基本的存储单元是slot（变量槽）

JVM会为局部变量表中的每一个slot分配一个访问索引，通过这个索引即可访问到局部变量表中指定的局部变量值。

当一个实例方法被调用的时候，它的每一个方法参数和方法体内部的局部变量将会**按照顺序被复制**到局部变量表中的每一个slot上。

如果需要访问局部变量表中一个64 bit的局部变量时，只需使用前一个索引即可（如：long和double类型变量）

如果当前帧是由构造方法或实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。

栈中的局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，之后申明的新的局部变量就很有可能复用过期局部变量的槽位，从而达到节省资源的目的。



在局部变量表里，32位以内的类型只占用一个slot（槽位）（包括return Address），64位类型的（double和long）占用两个slot。

byte、short、char在存储前被转换为int，boolean也被转成int，0表示false，非零表示true，引用类型存储引用地址占一个槽位。

局部变量表建立在线程栈中，是线程私有的数据，不存在并发访问题。

局部变量表的大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables中，在运行期间不会改变局部变量表的大小。

局部变量中的变量也是重要的垃圾回收的根节点（GC Root），只要被局部变量表中的变量直接或间接引用的对象都不会被回收。

* **操作数栈（Operand Stack）**

主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。

操作数栈就是JVM执行引擎的一个工作区，当一个方法开始执行时一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。

操作数栈其所需的最大深度在编译期间就定义好了，保存在方法的Code属性中，为max_stack的值。

栈中32 bit的类型占用一个栈单位深度，64 bit的类型占用两个栈单位深度

操作数栈只能通过push和pop操作来完成一次数据访问。

如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器下一条需要执行的字节码指令

使用`javap -v *.class`反编译class文件



 

* **动态链接（Dynamic Linking）**
  * Class文件的常量池中存在有大量的符号引用,字节码中的方法调用指令就以指向常量池的引用作为参数
    * 部分符号引用在类加载阶段(解析)的时候就转化为直接引用,这种转化为**静态链接**
    * 部分符号引用在运行期间转化为直接引用,这种转化为**动态链接**

* **方法返回值地址（Return Address）**

- 存放调用该方法的PC寄存器的值,一个方法的结束有两种方式 正常执行完成 和出现未处理异常非正常退出。
- 无论哪种方式退出,在方法退出后都返回到该方法被调用的位置，方法正常退出，调用者的PC寄存器的值作为返回地址,即调用该方法的指令的下一条在指令的地址。

* 一些附加信息
  * 栈帧允许携带一些与JVM实现相关的附加信息,如对程序调优提供支持的信息



- 存储单位
- 代码追踪


- 栈顶缓存技术
- 方法的调用：解析与分派

#### 本地方法栈（Native Method Stack）

一个本地方法就是一个由非Java代码实现的Java方法



#### 程序计数器（Program Counter Register）

是对物理PC寄存器的一种模拟，用来存储指向下一条指令的地址（将要执行的指令），由执行引擎读取。它是一块很小的内存空间。在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程一致。

任何时间一个线程都有一个方法正在执行，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；如果是native方法则是未指定值（undefined）。

它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖程序计数器来完成。

字节码解释器工作时就是通过改变这个计数器的值选取下一条需要执行的字节码指令。

它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

通常是运行速度最快的一个区域。

## 对象实例化

### 创建对象的方式

- new关键字（变形： 单例模式、工厂模式、建造者模式）
- Class的`newInstance()`，只能调用无参构造器，权限必须是public
- Constructor的`newInstance(**)`可以调用无参、带参数的构造器，权限没有要求。
- 使用`clone()`不调用任何构造器，当前类需要实现`Cloneable`接口，实现`clone()`方法
- 使用反序列化
- 第三方库`Objenesis`

### 创建对象的步骤

1. 判断对象对应的类是否加载、链接、初始化

   - 虚拟机遇到一条`new`指令， 首先检查这个指令的参数是否能在`MetaSpace`的常量池中定位到一个类的符号引用。并检查这个符号引用代表的类是否已经被加载、解析和初始化。（判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以`ClassLoader+包名+类命`为Key查找对应的`.class`文件。如果没有找到文件，则抛出`ClassNotFoundException`异常，如果找到则进行类加载，并生成对应的Class类对象。

2. 为对象分配内存

   - 首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节。

   - 如果内存**是规整的**，那么JVM将采用指针碰撞（Bump To Pointer）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存就是仅仅是把指针向空闲那边挪动一小段与对象大小相等的距离罢了，如果垃圾收集器选择的是`Serial`、`ParNew`这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有`compact`（整理）过程的收集器时，使用指针碰撞。
   - 如果内存是**不规整的**，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。空闲列表法即虚拟机维护的一个列表，记录上哪块内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新表上的内容。

3. 并发安全问题

   - 采用`CAS`失败重试、区域加锁保证更新的原子性。
   - 每个线程预先分配一块`TLAB`通过`-XX:+/-UseTLAB`参数来设定。

4. 初始化分配到的空间

   - 所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用。

5. 设置对象的头

   - 将对象所属的类（类的元数据信息）、对象的`HashCode`和对象的`GC`和锁等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。

6. 执行`init`方法进行初始化

   - 在Java程序的视角来看，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说（由字节码中是否跟随有`invokespecial`指令所决定），new指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。

### 对象的内存布局

- 对象头（Header）
  - 运行时元数据（Mark Word）
    - 哈希值`HashCode`
    - `GC`分代年龄
    - 锁状态标志
    - 线程持有的锁
    - 偏向线程ID
    - 偏向时间戳
  - 类型指针
    - 指向类元数据Instance Class，确定该对象所属的类型
  - 如果是数组，还需要记录数组的长度
- 实例数据（Instance Data）
  - 它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承的和自身定义的字段）
  - 相同宽度的字段总是被分配在一起
  - 父类的字段会出现在子类字段之前
  - 如果`CompactFields`参数为true（默认为true），子类的窄变量可能插入到父类变量的空隙。
- 对象填充（Padding）
- 小结
- ![](C:\Users\11690\Desktop\Markdown\对象内存布局.jpg)

### 对象访问定位

- 句柄访问

  - 图示

  ![](C:\Users\11690\Desktop\Markdown\对象定位-句柄访问.png)

  - 实现
    - 句柄包含对象实例数据的指针和对象类型信息的指针，间接访问对象实例数据和对象类型数据。
  - 优点
    - 局部变量表中存储句柄信息，对象移动时（垃圾回收时移动对象很普遍）只会改变句柄中实例数据指针，局部变量表中存储的句柄信息不需要被修改。

- 直接指针（Hotspot采用）

  - 图示

  ![](C:\Users\11690\Desktop\Markdown\对象定位-直接指针.png)

  - 实现
    - 局部变量表中的引用对象直接指向堆空间的对象实例数据。
  - 优点
    - 可以直接访问对象实例数据，访问效率更高。

## 执行引擎（Execution Engine）

### 概述

- `JVM`核心组成部分之一
- 执行引擎的任务就是将指令解释/编译为对应平台上的本地机器指令才可以，`JVM`中的执行引擎充当了将高级语言翻译为机器语言的翻译。
- **输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果**。

## Java代码编译和执行的过程



![](C:\Users\11690\Desktop\Markdown\Java代码编译和执行过程.png)

- `-Xint`切换成编译器模式
- `-Xcomp`切换成JIT模式
- `-Xmixed`混合模式

### 解释器

- 当`JVM`启动时会根据预定义的规范**对字节码采用逐行解释执行的方式**，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。

### 即时编译器

- `JIT`（Just In Time Complier）编译器，就是虚拟机将源代码（字节码）直接编译成本地机器平台相关的机器语言。

- `Hotspot`虚拟机内嵌了两个`JIT`，分别为Server Compile和Client Compile，大多数情况我们简称为`C1`编译器和`C2`编译器，开发人员可以通过以下命令显式指定`JVM`在运行时到底使用哪一种编译器。

- `-client`指定虚拟机在Client模式下运行，并使用`C1`编译器

  - `C1`编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。

- `-server`指定虚拟机在Server模式下运行，并使用`C2`编译器（64位机器支支持server模式）

  - `C2`进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。

- 热点代码及探测方式

  - 是否需要启动`JIT`编译器将字节码直接编译为机器码则需要根据代码被调用**执行频率**而定，那些需要被编译成对应平台的机器指令的字节码称之为**热点代码**，`JIT`编译器在运行时会针对那些频繁被调用的代码做出深度优化，将其直接编译成对应平台的机器指令，以提升Java程序的性能。

  - 一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为**热点代码**，因此都可以通过`JIT`编译器编译成本地机器指令。由于这种编译方式发生在方法的指令过程中，因此也被称之为站上替换`OSR`（On Stack Replacement）编译。

  - 目前`Hotspot`所采用的，热点探测方式是基于计数器的热点探测

    - `Hotspot`虚拟机会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）.

      - 方法调用计数器用于统计方法的调用次数。
      - 回边计数器用于统计循环体执行的循环次数。

    - 回边计数器

      ![](C:\Users\11690\Desktop\Markdown\回边计数器.png)

    - 方法调用计数器

      - 它的默认阈值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发`JIT`
      - 这个阈值可以通过参数`-XX:CompileThreshold`来设置。
      - 图示（是否超过阈值会判断方法调用计数器和回边计数器的和是否超过阈值）

      ![](C:\Users\11690\Desktop\Markdown\方法调用计数器.jpg)

      - 热度衰减
        - 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数，当超过**时间限度**，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的程序计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay）,而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）。
        - 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数`-XX:-UseCounterDecay`来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话只要系统运行时间够长，绝大多数方法都会被编译成本地代码。
        - 可以使用`-XX:CounterHalfLifeTime`参数设置半衰周期的时间，单位是秒。

![](C:\Users\11690\Desktop\Markdown\执行引擎.jpg)

### AOT编译器

- `JDK9`引入`AOT`编译器,静态提前编译器（Ahead Of Time Compiler）
- `JDK9`引入实验性`AOT`编译工具`jaotc`。它借助了`Graal`编译器，将所输入的Java类文件转换成机器码，并存放至生成的动态共享库之中。
- `AOT`编译是与即时编译相对立的一个概念，`AOT`指的是在程序运行之前便将字节码转换成机器码的过程。
  - 缺点
    - 破坏了Java“一次编译，打出运行”的特征。
    - 降低了Java连接过程的动态性，加载的代码在编译期就必须全部已知



## StringTable

### String的基本特性

- 不可变类，不可被继承。
- 实现了Serializable、Comparable接口
- `JDK8`及之前版本内部定义了final char[] value用于存储字符串数据。`JDK9`改成了byte[]。
  - 现状是很多情况下一个byte可以存下一个字符（汉字不行），用byte可以节省一半空间。
- 字符串常量池中是不会存储相同内容的字符串的。
  - String的String Pool是一个固定大小的`Hashtable`，默认长度是1009，如果放入String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了之后会造成的影响就是当调用`String.intern()`时性能会大幅下降。
  - 使用`-XX:StringTableSize`可设置`StringTable`的长度。
  - 在`JDK6`中`StringTable`的长度是固定的，就是1009，所以如果常量池中的，字符串过多就会导致效率下降很快。`StringTableSize`设置没有要求。
  - 在`JDK8`中`StringTable`的长度默认值是60013，1009是可以设置的最小值。
- String的内存分配
  - 



## 垃圾回收器

## 本地方法接口（Native Interface）

## 字节码和类的加载

一个有效的字节码文件除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。

常量池可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法、参数类型和字面量等类型。

![字节码文件](C:\Users\11690\Desktop\Markdown\字节码文件.png)



## 性能监控与调优

## 线程

## 直接内存

- 不是虚拟机运行时数据的一部分，也不是《Java虚拟机规范》中定义的内存区域
- 直接内存不是在Java堆上的，是直接向系统申请的内存空间。
- 来源于`NIO`通过堆中的`DirectByteBuffer`操作本地内存。

- 通常访问直接内存的速度会优于Java堆，即读写性能高。
  - 因此出于性能考虑，读写频繁的场景可能会考虑使用直接内存
  - Java的`NIO`库允许Java程序使用直接内存,用于数据缓冲区。



## 面试

